# SPDX-License-Identifier: MIT
# Copyright (c) 2025-2026 Kaptain contributors (Fred Cooke)

name: Spec Check Filter Release
kaptain-order: 90
kaptain-description: Everything from quality and version above, but also validates and packages a JSON Schema or an API Spec
on:
  workflow_call:
    inputs:
      # INJECT-INPUT: output-sub-path

      # Docker registry logins
      docker-registry-logins:
        description: 'YAML config for Docker registry logins (registry URL as key)'
        required: false
        type: string
        default: ''
      # Docker target config
      docker-target-registry:
        description: 'Target container registry'
        required: false
        type: string
        default: 'ghcr.io'
      docker-target-base-path:
        description: 'Path between registry and image name (auto-set for GHCR)'
        required: false
        type: string
        default: ''
      # Docker push targets
      docker-push-targets:
        description: 'JSON array of additional push targets [{registry, base-path?}]'
        required: false
        type: string
        default: ''
      # Docker build options
      dockerfile-sub-path:
        description: 'Directory containing Dockerfile, relative to repo root.'
        required: false
        type: string
        default: 'src/docker'
      dockerfile-squash:
        description: 'Enable --squash (requires experimental mode)'
        required: false
        type: boolean
        default: true
      dockerfile-no-cache:
        description: 'Disable layer caching for reproducible builds'
        required: false
        type: boolean
        default: true

      # Spec configuration
      spec-type:
        description: 'Type of spec (schema or api)'
        required: true
        type: string
      spec-validation-type:
        description: 'Schema validator to use (basic, python3-jsonschema)'
        required: false
        type: string
        default: 'basic'
      spec-packaging-base-image:
        description: 'Base image for spec packaging'
        required: false
        type: string
        default: 'scratch'

      # INJECT-INPUT: token-substitution

      # INJECT-INPUT: release-branches
      # INJECT-INPUT: tag-version

      # INJECT-INPUT: basic-quality-checks

      # INJECT-INPUT: hooks-pre-tagging

      # INJECT-INPUT: github-release
    secrets:
      docker-registry-logins-secrets:
        description: 'JSON object of secrets for docker-registry-logins (e.g., {"DOCKER_USER": "x", "DOCKER_PASS": "y"})'
        required: false
    outputs:
      # Version outputs
      version:
        description: 'The generated version'
        value: ${{ jobs.build.outputs.version }}
      version-major:
        description: 'Major version number'
        value: ${{ jobs.build.outputs.version-major }}
      version-minor:
        description: 'Minor version number'
        value: ${{ jobs.build.outputs.version-minor }}
      version-patch:
        description: 'Patch version number'
        value: ${{ jobs.build.outputs.version-patch }}
      version-2-part:
        description: 'Version padded/truncated to 2 parts'
        value: ${{ jobs.build.outputs.version-2-part }}
      version-3-part:
        description: 'Version padded/truncated to 3 parts'
        value: ${{ jobs.build.outputs.version-3-part }}
      version-4-part:
        description: 'Version padded/truncated to 4 parts'
        value: ${{ jobs.build.outputs.version-4-part }}
      docker-tag:
        description: 'Tag for Docker images'
        value: ${{ jobs.build.outputs.docker-tag }}
      docker-image-name:
        description: 'Docker image name'
        value: ${{ jobs.build.outputs.docker-image-name }}
      git-tag:
        description: 'Tag for git'
        value: ${{ jobs.build.outputs.git-tag }}
      project-name:
        description: 'The repository/project name'
        value: ${{ jobs.build.outputs.project-name }}
      is-release:
        description: 'Whether this is a release build'
        value: ${{ jobs.build.outputs.is-release }}
      # Build outputs
      docker-target-image-full-uri:
        description: 'Full target image reference'
        value: ${{ jobs.build.outputs.docker-target-image-full-uri }}
      docker-image-pushed:
        description: 'Whether docker image was pushed'
        value: ${{ jobs.build.outputs.docker-image-pushed }}
      docker-substituted-sub-path:
        description: 'Directory containing substituted files (relative)'
        value: ${{ jobs.build.outputs.docker-substituted-sub-path }}
      spec-yaml:
        description: 'File name of spec YAML file'
        value: ${{ jobs.build.outputs.spec-yaml }}
      spec-json:
        description: 'File name of spec JSON file'
        value: ${{ jobs.build.outputs.spec-json }}
jobs:
  basic-quality-checks:
    name: Basic Quality Checks
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-24.04
    permissions:
      contents: read
    steps:
      # INJECT: parse-workflow-ref-and-checkout
      # INJECT: basic-quality-checks
  build:
    name: Build & Push
    needs: basic-quality-checks
    if: always() && (needs.basic-quality-checks.result == 'success' || needs.basic-quality-checks.result == 'skipped')
    runs-on: ubuntu-24.04
    permissions:
      contents: write
      packages: write
      checks: write
    outputs:
      version: ${{ steps.versions.outputs.version }}
      version-major: ${{ steps.versions.outputs.version-major }}
      version-minor: ${{ steps.versions.outputs.version-minor }}
      version-patch: ${{ steps.versions.outputs.version-patch }}
      version-2-part: ${{ steps.versions.outputs.version-2-part }}
      version-3-part: ${{ steps.versions.outputs.version-3-part }}
      version-4-part: ${{ steps.versions.outputs.version-4-part }}
      docker-tag: ${{ steps.versions.outputs.docker-tag }}
      docker-image-name: ${{ steps.versions.outputs.docker-image-name }}
      git-tag: ${{ steps.versions.outputs.git-tag }}
      project-name: ${{ steps.versions.outputs.project-name }}
      is-release: ${{ steps.versions.outputs.is-release }}
      docker-target-image-full-uri: ${{ steps.docker-build.outputs.docker-target-image-full-uri }}
      docker-image-pushed: ${{ steps.docker-push.outputs.image-pushed }}
      docker-substituted-sub-path: ${{ steps.docker-build.outputs.docker-substituted-sub-path }}
      spec-yaml: ${{ steps.spec-package-prepare.outputs.SPEC_YAML }}
      spec-json: ${{ steps.spec-package-prepare.outputs.SPEC_JSON }}
    steps:
      # INJECT: parse-workflow-ref-and-checkout

      # === Docker Registry Logins ===
      # INJECT: docker-registry-logins

      # === Pre-tagging Tests ===
      # INJECT: github-check-start(name="Pre-tagging Tests", id="check-pre-tagging", if="inputs.hook-pre-tagging-tests-script-sub-path != ''")
      # INJECT: hook-pre-tagging-tests
      # INJECT: github-check-end(name="Pre-tagging Tests", id="check-pre-tagging", if="inputs.hook-pre-tagging-tests-script-sub-path != ''")

      # === Versions & Naming ===
      # INJECT: github-check-start(name="Versions & Naming", id="check-versions")
      # INJECT: versions-and-naming
      # INJECT: github-check-end(name="Versions & Naming", id="check-versions")

      # === Spec Package Prepare ===
      # INJECT: github-check-start(name="Spec Package Prepare", id="check-spec-prepare")
      - name: Spec package prepare
        id: spec-package-prepare
        shell: bash
        env:
          PROJECT_NAME: ${{ steps.versions.outputs.project-name }}
          VERSION: ${{ steps.versions.outputs.version }}
          OUTPUT_SUB_PATH: ${{ inputs.output-sub-path }}
          SPEC_PACKAGING_BASE_IMAGE: ${{ inputs.spec-packaging-base-image }}
        run: ./.github/buildon-github-actions/src/scripts/main/spec-package-prepare
      # INJECT: github-check-end(name="Spec Package Prepare", id="check-spec-prepare")

      # === Docker Build ===
      # INJECT: github-check-start(name="Docker Build", id="check-docker-build")
      - name: Build image
        id: docker-build
        uses: ./.github/buildon-github-actions/src/actions/docker-build-dockerfile
        with:
          docker-target-registry: ${{ inputs.docker-target-registry }}
          docker-target-base-path: ${{ inputs.docker-target-base-path }}
          docker-image-name: ${{ steps.versions.outputs.docker-image-name }}
          docker-tag: ${{ steps.versions.outputs.docker-tag }}
          version: ${{ steps.versions.outputs.version }}
          project-name: ${{ steps.versions.outputs.project-name }}
          is-release: ${{ steps.versions.outputs.is-release }}
          dockerfile-sub-path: ${{ steps.spec-package-prepare.outputs.DOCKERFILE_SUB_PATH }}
          dockerfile-squash: ${{ inputs.dockerfile-squash }}
          dockerfile-no-cache: ${{ inputs.dockerfile-no-cache }}
          output-sub-path: ${{ inputs.output-sub-path }}
          token-delimiter-style: ${{ inputs.token-delimiter-style }}
          token-name-style: ${{ inputs.token-name-style }}
          token-name-validation: ${{ inputs.token-name-validation }}
          config-sub-path: ${{ inputs.config-sub-path }}
          allow-builtin-token-override: ${{ inputs.allow-builtin-token-override }}
          config-value-trailing-newline: ${{ inputs.config-value-trailing-newline }}
      # INJECT: github-check-end(name="Docker Build", id="check-docker-build")

      # === Docker Multi-Tag ===
      # INJECT: github-check-start(name="Docker Multi-Tag", id="check-docker-multi-tag", if="inputs.docker-push-targets != '' && steps.versions.outputs.is-release == 'true'")
      # INJECT: docker-multi-tag
      # INJECT: github-check-end(name="Docker Multi-Tag", id="check-docker-multi-tag", if="inputs.docker-push-targets != '' && steps.versions.outputs.is-release == 'true'")

      # === Spec Validate ===
      # INJECT: github-check-start(name="Spec Validate", id="check-spec-validate")
      - name: Spec validate
        id: spec-validate
        shell: bash
        env:
          SPEC_TYPE: ${{ inputs.spec-type }}
          SPEC_VALIDATION_TYPE: ${{ inputs.spec-validation-type }}
          SPEC_SUB_PATH: ${{ steps.docker-build.outputs.docker-substituted-sub-path }}
          SPEC_JSON: ${{ steps.spec-package-prepare.outputs.SPEC_JSON }}
        run: ./.github/buildon-github-actions/src/scripts/main/spec-validate
      # INJECT: github-check-end(name="Spec Validate", id="check-spec-validate")

      # === Spec GitHub Release Prepare ===
      # INJECT: github-check-start(name="Spec GitHub Release Prepare", id="check-spec-github-release-prepare", if="inputs.github-release-enabled == true")
      - name: Prepare spec files for release
        id: prepare-spec-release
        if: inputs.github-release-enabled == true
        shell: bash
        env:
          OUTPUT_SUB_PATH: ${{ inputs.output-sub-path }}
          SUBSTITUTED_SUB_PATH: ${{ steps.docker-build.outputs.docker-substituted-sub-path }}
          SPEC_YAML: ${{ steps.spec-package-prepare.outputs.SPEC_YAML }}
          SPEC_JSON: ${{ steps.spec-package-prepare.outputs.SPEC_JSON }}
          VERSION: ${{ steps.versions.outputs.version }}
        run: |
          set -euo pipefail
          RELEASE_DIR="${OUTPUT_SUB_PATH}/github-release"
          mkdir -p "${RELEASE_DIR}"

          # Add version suffix to filename (e.g., spec.yaml -> spec-1.2.3.yaml)
          add_version_suffix() {
            local filename="$1"
            local base ext
            if [[ "${filename}" == *.* ]]; then
              base="${filename%.*}"
              ext="${filename##*.}"
              echo "${base}-${VERSION}.${ext}"
            else
              echo "${filename}-${VERSION}"
            fi
          }

          # Copy spec files (already substituted by docker-build) with version suffix
          SPEC_YAML_VERSIONED=$(add_version_suffix "${SPEC_YAML}")
          SPEC_JSON_VERSIONED=$(add_version_suffix "${SPEC_JSON}")

          cp "${SUBSTITUTED_SUB_PATH}/${SPEC_YAML}" "${RELEASE_DIR}/${SPEC_YAML_VERSIONED}"
          cp "${SUBSTITUTED_SUB_PATH}/${SPEC_JSON}" "${RELEASE_DIR}/${SPEC_JSON_VERSIONED}"

          echo "Prepared spec files for release:"
          echo "  ${SPEC_YAML} -> ${SPEC_YAML_VERSIONED}"
          echo "  ${SPEC_JSON} -> ${SPEC_JSON_VERSIONED}"

          # Output versioned filenames for release notes
          echo "spec-yaml-versioned=${SPEC_YAML_VERSIONED}" >> "${GITHUB_OUTPUT}"
          echo "spec-json-versioned=${SPEC_JSON_VERSIONED}" >> "${GITHUB_OUTPUT}"
      # INJECT: github-check-end(name="Spec GitHub Release Prepare", id="check-spec-github-release-prepare", if="inputs.github-release-enabled == true")

      # === GitHub Release Prepare ===
      # INJECT: github-check-start(name="GitHub Release Prepare", id="check-github-release-prepare", if="inputs.github-release-enabled == true")
      # INJECT: github-release-prepare-docker
      # INJECT: github-check-end(name="GitHub Release Prepare", id="check-github-release-prepare", if="inputs.github-release-enabled == true")

      # === Git Tag Push ===
      # INJECT: github-check-start(name="Git Tag Push", id="check-git-push-tag", if="steps.versions.outputs.is-release == 'true'")
      # INJECT: git-push-tag
      # INJECT: github-check-end(name="Git Tag Push", id="check-git-push-tag", if="steps.versions.outputs.is-release == 'true'")

      # === Docker Push ===
      # INJECT: github-check-start(name="Docker Push", id="check-docker-push", if="steps.versions.outputs.is-release == 'true'")
      # INJECT: docker-push
      # INJECT: github-check-end(name="Docker Push", id="check-docker-push", if="steps.versions.outputs.is-release == 'true'")

      # === Docker Multi-Push ===
      # INJECT: github-check-start(name="Docker Multi-Push", id="check-docker-multi-push", if="inputs.docker-push-targets != '' && steps.versions.outputs.is-release == 'true'")
      # INJECT: docker-multi-push
      # INJECT: github-check-end(name="Docker Multi-Push", id="check-docker-multi-push", if="inputs.docker-push-targets != '' && steps.versions.outputs.is-release == 'true'")

      # === GitHub Release ===
      # INJECT: github-check-start(name="GitHub Release", id="check-github-release", if="inputs.github-release-enabled == true && steps.versions.outputs.is-release == 'true'")
      - name: Compute release notes
        id: release-notes
        if: inputs.github-release-enabled == true && steps.versions.outputs.is-release == 'true' && success()
        shell: bash
        env:
          USER_NOTES: ${{ inputs.github-release-notes }}
          VERSION: ${{ steps.versions.outputs.version }}
          PROJECT_NAME: ${{ steps.versions.outputs.project-name }}
          DOCKER_URI: ${{ steps.docker-build.outputs.docker-target-image-full-uri }}
          SPEC_TYPE: ${{ inputs.spec-type }}
          SPEC_YAML: ${{ steps.prepare-spec-release.outputs.spec-yaml-versioned }}
          SPEC_JSON: ${{ steps.prepare-spec-release.outputs.spec-json-versioned }}
          GITHUB_SERVER_URL: ${{ github.server_url }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          display_name=$(./.github/buildon-github-actions/src/scripts/util/format-project-title "${PROJECT_NAME}")
          echo "title=${VERSION} â€” ${display_name}" >> "${GITHUB_OUTPUT}"

          if [[ -n "${USER_NOTES}" ]]; then
            # User provided notes override entirely
            {
              echo "notes<<NOTES_EOF"
              echo "${USER_NOTES}"
              echo "NOTES_EOF"
            } >> "${GITHUB_OUTPUT}"
          else
            # Default format
            if [[ "${SPEC_TYPE}" == "schema" ]]; then
              type_label="Schema"
            else
              type_label="API Spec"
            fi
            release_url="${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/releases/download/${VERSION}"
            {
              echo "notes<<NOTES_EOF"
              echo "Automatic ${type_label} release for version ${VERSION} of ${PROJECT_NAME} by Kaptain build script. This release includes both YAML and JSON formats of the spec, and a Docker image with both files bundled."
              echo ""
              echo "### Release Assets"
              echo "* ${type_label} YAML: [${SPEC_YAML}](${release_url}/${SPEC_YAML})"
              echo "* ${type_label} JSON: [${SPEC_JSON}](${release_url}/${SPEC_JSON})"
              echo "* Docker Image: [${DOCKER_URI}](https://${DOCKER_URI})"
              echo "NOTES_EOF"
            } >> "${GITHUB_OUTPUT}"
          fi
      - name: GitHub Release
        if: inputs.github-release-enabled == true && steps.versions.outputs.is-release == 'true' && success()
        uses: ./.github/buildon-github-actions/src/actions/github-release
        with:
          github-release-enabled: ${{ inputs.github-release-enabled }}
          output-sub-path: ${{ inputs.output-sub-path }}
          github-release-tag: ${{ steps.versions.outputs.version }}
          github-release-notes: ${{ steps.release-notes.outputs.notes }}
          github-release-title: ${{ steps.release-notes.outputs.title }}
      # INJECT: github-check-end(name="GitHub Release", id="check-github-release", if="inputs.github-release-enabled == true && steps.versions.outputs.is-release == 'true'")
