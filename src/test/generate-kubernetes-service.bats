#!/usr/bin/env bats
# SPDX-License-Identifier: MIT
# Copyright (c) 2025-2026 Kaptain contributors (Fred Cooke)
#
# Tests for generate-kubernetes-service

load helpers

setup() {
  export OUTPUT_SUB_PATH=$(create_test_dir "gen-svc")
  export PROJECT_NAME="my-project"
  export TOKEN_NAME_STYLE="PascalCase"
  export TOKEN_DELIMITER_STYLE="shell"
  export KUBERNETES_SERVICE_GENERATION_ENABLED="true"
}

teardown() {
  :
}

# Helper to read generated manifest
read_manifest() {
  cat "$OUTPUT_SUB_PATH/manifests/combined/service.yaml"
}

read_manifest_with_suffix() {
  local suffix="$1"
  cat "$OUTPUT_SUB_PATH/manifests/combined/service-${suffix}.yaml"
}

read_manifest_in_subpath() {
  local subpath="$1"
  cat "$OUTPUT_SUB_PATH/manifests/combined/${subpath}/service.yaml"
}

# =============================================================================
# Generation enabled/disabled
# =============================================================================

@test "skips generation when not enabled" {
  export KUBERNETES_SERVICE_GENERATION_ENABLED="false"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]
  [[ "$output" == *"not enabled"* ]]
  [ ! -f "$OUTPUT_SUB_PATH/manifests/combined/service.yaml" ]
}

@test "skips generation when enabled not set and workload is not deployment" {
  unset KUBERNETES_SERVICE_GENERATION_ENABLED
  export KUBERNETES_WORKLOAD_TYPE="none"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]
  [[ "$output" == *"not enabled"* ]]
  [ ! -f "$OUTPUT_SUB_PATH/manifests/combined/service.yaml" ]
}

@test "enables generation by default for deployment workload" {
  unset KUBERNETES_SERVICE_GENERATION_ENABLED
  export KUBERNETES_WORKLOAD_TYPE="deployment"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]
  [ -f "$OUTPUT_SUB_PATH/manifests/combined/service.yaml" ]
}

@test "generates when explicitly enabled" {
  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]
  [ -f "$OUTPUT_SUB_PATH/manifests/combined/service.yaml" ]
}

# =============================================================================
# Basic functionality
# =============================================================================

@test "generates valid Service structure" {
  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"apiVersion: v1"* ]]
  [[ "$manifest" == *"kind: Service"* ]]
  [[ "$manifest" == *"metadata:"* ]]
  [[ "$manifest" == *'name: ${ProjectName}'* ]]
  [[ "$manifest" == *'namespace: ${Environment}'* ]]
}

@test "includes spec section" {
  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"spec:"* ]]
  [[ "$manifest" == *"type: ClusterIP"* ]]
  [[ "$manifest" == *"selector:"* ]]
  [[ "$manifest" == *'app: ${ProjectName}'* ]]
  [[ "$manifest" == *"ports:"* ]]
}

@test "includes standard labels" {
  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"labels:"* ]]
  [[ "$manifest" == *'app: ${ProjectName}'* ]]
  [[ "$manifest" == *'app.kubernetes.io/name: ${ProjectName}'* ]]
  [[ "$manifest" == *'app.kubernetes.io/version: ${Version}'* ]]
  [[ "$manifest" == *"app.kubernetes.io/managed-by: Kaptain"* ]]
}

@test "includes kaptain annotations" {
  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"annotations:"* ]]
  [[ "$manifest" == *'kaptain/project-name: ${ProjectName}'* ]]
  [[ "$manifest" == *'kaptain/version: ${Version}'* ]]
  [[ "$manifest" == *"kaptain/build-timestamp:"* ]]
  [[ "$manifest" == *'kaptain/generated-by: "Generated by Kaptain generate-kubernetes-service"'* ]]
}

# =============================================================================
# Service type
# =============================================================================

@test "defaults to ClusterIP type" {
  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"type: ClusterIP"* ]]
}

@test "respects NodePort type" {
  export KUBERNETES_SERVICE_TYPE="NodePort"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"type: NodePort"* ]]
}

@test "respects LoadBalancer type" {
  export KUBERNETES_SERVICE_TYPE="LoadBalancer"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"type: LoadBalancer"* ]]
}

@test "fails with invalid service type" {
  export KUBERNETES_SERVICE_TYPE="invalid"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 4 ]
}

# =============================================================================
# Port configuration
# =============================================================================

@test "defaults to port 80 and targetPort 1024" {
  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"port: 80"* ]]
  [[ "$manifest" == *"targetPort: 1024"* ]]
}

@test "respects custom service port" {
  export KUBERNETES_SERVICE_PORT="8080"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"port: 8080"* ]]
  [[ "$manifest" == *"targetPort: 1024"* ]]
}

@test "targetPort defaults to container port" {
  export KUBERNETES_WORKLOAD_CONTAINER_PORT="3000"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"port: 80"* ]]
  [[ "$manifest" == *"targetPort: 3000"* ]]
}

@test "respects different target port" {
  export KUBERNETES_SERVICE_PORT="80"
  export KUBERNETES_SERVICE_TARGET_PORT="8080"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"port: 80"* ]]
  [[ "$manifest" == *"targetPort: 8080"* ]]
}

@test "defaults to TCP protocol" {
  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"protocol: TCP"* ]]
}

@test "respects UDP protocol" {
  export KUBERNETES_SERVICE_PROTOCOL="UDP"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"protocol: UDP"* ]]
}

@test "fails with invalid protocol" {
  export KUBERNETES_SERVICE_PROTOCOL="invalid"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 7 ]
}

# =============================================================================
# Token styles
# =============================================================================

@test "respects PascalCase token name style" {
  export TOKEN_NAME_STYLE="PascalCase"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *'${ProjectName}'* ]]
  [[ "$manifest" == *'${Environment}'* ]]
}

@test "respects lower-kebab token name style" {
  export TOKEN_NAME_STYLE="lower-kebab"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *'${project-name}'* ]]
  [[ "$manifest" == *'${environment}'* ]]
}

@test "respects mustache substitution style" {
  export TOKEN_DELIMITER_STYLE="mustache"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *'{{ ProjectName }}'* ]]
  [[ "$manifest" == *'{{ Environment }}'* ]]
}

@test "fails with unknown token name style" {
  export TOKEN_NAME_STYLE="unknown"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 2 ]
}

@test "fails with unknown substitution token style" {
  export TOKEN_DELIMITER_STYLE="unknown"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 3 ]
}

# =============================================================================
# Output paths
# =============================================================================

@test "creates output directory if missing" {
  # Use a fresh subdirectory that doesn't exist yet
  export OUTPUT_SUB_PATH="${OUTPUT_SUB_PATH}/fresh-subdir"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]
  [ -f "$OUTPUT_SUB_PATH/manifests/combined/service.yaml" ]
}

@test "respects custom OUTPUT_SUB_PATH" {
  export OUTPUT_SUB_PATH=$(create_test_dir "gen-svc-custom")

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]
  [ -f "$OUTPUT_SUB_PATH/manifests/combined/service.yaml" ]
}

# =============================================================================
# Additional labels and annotations
# =============================================================================

@test "adds global additional labels" {
  export KUBERNETES_GLOBAL_ADDITIONAL_LABELS="team=platform,cost-center=123"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"team: platform"* ]]
  [[ "$manifest" == *"cost-center: 123"* ]]
}

@test "adds service-specific additional labels" {
  export KUBERNETES_SERVICE_ADDITIONAL_LABELS="svc-label=value"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"svc-label: value"* ]]
}

@test "service labels override global labels" {
  export KUBERNETES_GLOBAL_ADDITIONAL_LABELS="team=platform"
  export KUBERNETES_SERVICE_ADDITIONAL_LABELS="team=override"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"team: override"* ]]
  [[ "$manifest" != *"team: platform"* ]]
}

@test "adds global additional annotations" {
  export KUBERNETES_GLOBAL_ADDITIONAL_ANNOTATIONS="example.com/note=test"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"example.com/note: test"* ]]
}

@test "adds service-specific additional annotations" {
  export KUBERNETES_SERVICE_ADDITIONAL_ANNOTATIONS="service.beta.kubernetes.io/aws-load-balancer-internal=true"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"service.beta.kubernetes.io/aws-load-balancer-internal: true"* ]]
}

# =============================================================================
# Name suffix
# =============================================================================

@test "suffix affects metadata.name" {
  export KUBERNETES_SERVICE_NAME_SUFFIX="api"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest_with_suffix "api")
  [[ "$manifest" == *'name: ${ProjectName}-api'* ]]
}

@test "suffix affects output filename" {
  export KUBERNETES_SERVICE_NAME_SUFFIX="api"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]
  [ -f "$OUTPUT_SUB_PATH/manifests/combined/service-api.yaml" ]
}

@test "no suffix uses default filename" {
  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]
  [ -f "$OUTPUT_SUB_PATH/manifests/combined/service.yaml" ]
}

# =============================================================================
# Combined sub-path
# =============================================================================

@test "combined sub-path creates subdirectory in combined/" {
  export KUBERNETES_SERVICE_COMBINED_SUB_PATH="apps/backend"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]
  [ -f "$OUTPUT_SUB_PATH/manifests/combined/apps/backend/service.yaml" ]
}

@test "combined sub-path affects metadata.name" {
  export KUBERNETES_SERVICE_COMBINED_SUB_PATH="apps-backend"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest_in_subpath "apps-backend")
  [[ "$manifest" == *'name: ${ProjectName}-apps-backend'* ]]
}

@test "combined sub-path with suffix: name is ProjectName-combined-suffix" {
  export KUBERNETES_SERVICE_COMBINED_SUB_PATH="apps"
  export KUBERNETES_SERVICE_NAME_SUFFIX="api"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  [ -f "$OUTPUT_SUB_PATH/manifests/combined/apps/service-api.yaml" ]
  manifest=$(cat "$OUTPUT_SUB_PATH/manifests/combined/apps/service-api.yaml")
  [[ "$manifest" == *'name: ${ProjectName}-apps-api'* ]]
}

@test "nested combined sub-path replaces slashes with hyphens in name" {
  export KUBERNETES_SERVICE_COMBINED_SUB_PATH="omg/wtf"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  [ -f "$OUTPUT_SUB_PATH/manifests/combined/omg/wtf/service.yaml" ]
  manifest=$(cat "$OUTPUT_SUB_PATH/manifests/combined/omg/wtf/service.yaml")
  [[ "$manifest" == *'name: ${ProjectName}-omg-wtf'* ]]
}

@test "combined sub-path validation rejects uppercase" {
  export KUBERNETES_SERVICE_COMBINED_SUB_PATH="Apps"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 5 ]
}

@test "combined sub-path validation rejects leading slash" {
  export KUBERNETES_SERVICE_COMBINED_SUB_PATH="/apps"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 6 ]
}

# =============================================================================
# Selector
# =============================================================================

@test "selector uses project name token" {
  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"selector:"* ]]
  [[ "$manifest" == *'app: ${ProjectName}'* ]]
}

# =============================================================================
# Headless service type
# =============================================================================

@test "Headless type sets clusterIP: None" {
  export KUBERNETES_SERVICE_TYPE="Headless"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"type: ClusterIP"* ]]
  [[ "$manifest" == *"clusterIP: None"* ]]
}

@test "Headless type includes selector" {
  export KUBERNETES_SERVICE_TYPE="Headless"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"selector:"* ]]
  [[ "$manifest" == *'app: ${ProjectName}'* ]]
}

@test "Headless type includes ports" {
  export KUBERNETES_SERVICE_TYPE="Headless"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"ports:"* ]]
  [[ "$manifest" == *"port: 80"* ]]
}

# =============================================================================
# NoSelector service type
# =============================================================================

@test "NoSelector type omits selector" {
  export KUBERNETES_SERVICE_TYPE="NoSelector"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" != *"selector:"* ]]
}

@test "NoSelector type includes ports" {
  export KUBERNETES_SERVICE_TYPE="NoSelector"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"ports:"* ]]
  [[ "$manifest" == *"port: 80"* ]]
}

# =============================================================================
# ExternalName service type
# =============================================================================

@test "ExternalName type requires external name" {
  export KUBERNETES_SERVICE_TYPE="ExternalName"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 4 ]
  [[ "$output" == *"KUBERNETES_SERVICE_EXTERNAL_NAME is required"* ]]
}

@test "ExternalName type sets externalName" {
  export KUBERNETES_SERVICE_TYPE="ExternalName"
  export KUBERNETES_SERVICE_EXTERNAL_NAME="my.external.service.com"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"type: ExternalName"* ]]
  [[ "$manifest" == *"externalName: my.external.service.com"* ]]
}

@test "ExternalName type omits ports" {
  export KUBERNETES_SERVICE_TYPE="ExternalName"
  export KUBERNETES_SERVICE_EXTERNAL_NAME="my.external.service.com"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" != *"ports:"* ]]
}

@test "ExternalName type omits selector" {
  export KUBERNETES_SERVICE_TYPE="ExternalName"
  export KUBERNETES_SERVICE_EXTERNAL_NAME="my.external.service.com"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" != *"selector:"* ]]
}

@test "ExternalName type omits clusterIP" {
  export KUBERNETES_SERVICE_TYPE="ExternalName"
  export KUBERNETES_SERVICE_EXTERNAL_NAME="my.external.service.com"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" != *"clusterIP:"* ]]
}

# =============================================================================
# NodePort specific features
# =============================================================================

@test "NodePort type allows nodePort specification" {
  export KUBERNETES_SERVICE_TYPE="NodePort"
  export KUBERNETES_SERVICE_NODE_PORT="30080"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"type: NodePort"* ]]
  [[ "$manifest" == *"nodePort: 30080"* ]]
}

@test "nodePort rejected for ClusterIP type" {
  export KUBERNETES_SERVICE_TYPE="ClusterIP"
  export KUBERNETES_SERVICE_NODE_PORT="30080"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 4 ]
  [[ "$output" == *"can only be used with NodePort"* ]]
}

# =============================================================================
# External traffic policy
# =============================================================================

@test "NodePort allows external traffic policy" {
  export KUBERNETES_SERVICE_TYPE="NodePort"
  export KUBERNETES_SERVICE_EXTERNAL_TRAFFIC_POLICY="Local"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"externalTrafficPolicy: Local"* ]]
}

@test "LoadBalancer allows external traffic policy" {
  export KUBERNETES_SERVICE_TYPE="LoadBalancer"
  export KUBERNETES_SERVICE_EXTERNAL_TRAFFIC_POLICY="Cluster"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"externalTrafficPolicy: Cluster"* ]]
}

@test "external traffic policy rejected for ClusterIP type" {
  export KUBERNETES_SERVICE_TYPE="ClusterIP"
  export KUBERNETES_SERVICE_EXTERNAL_TRAFFIC_POLICY="Local"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 4 ]
  [[ "$output" == *"can only be used with NodePort or LoadBalancer"* ]]
}

@test "invalid external traffic policy rejected" {
  export KUBERNETES_SERVICE_TYPE="NodePort"
  export KUBERNETES_SERVICE_EXTERNAL_TRAFFIC_POLICY="invalid"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 4 ]
  [[ "$output" == *"Must be 'Cluster' or 'Local'"* ]]
}

# =============================================================================
# Port name
# =============================================================================

@test "port name included when specified" {
  export KUBERNETES_SERVICE_PORT_NAME="http"

  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"name: http"* ]]
}

@test "port name omitted when not specified" {
  run "$GENERATORS_DIR/generate-kubernetes-service"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  # ports section should not have a name field (only port, targetPort, protocol)
  [[ "$manifest" != *"ports:"*"name:"* ]]
}
