#!/usr/bin/env bats
# SPDX-License-Identifier: MIT
# Copyright (c) 2025-2026 Kaptain contributors (Fred Cooke)
#
# Tests for generate-kubernetes-secret-template

load helpers

setup() {
  export KUBERNETES_SECRET_TEMPLATE_SUB_PATH=$(mktemp -d)
  export OUTPUT_SUB_PATH=$(mktemp -d)
  export PROJECT_NAME="my-project"
  export TOKEN_NAME_STYLE="PascalCase"
  export TOKEN_DELIMITER_STYLE="shell"
  export KUBERNETES_SECRET_TEMPLATE_NAME_CHECKSUM_INJECTION="true"
}

teardown() {
  rm -rf "$KUBERNETES_SECRET_TEMPLATE_SUB_PATH"
  rm -rf "${KUBERNETES_SECRET_TEMPLATE_SUB_PATH}.template"
  rm -rf "$OUTPUT_SUB_PATH"
}

# Helper to create a secret template file
# Note: .template is always appended as static suffix to the base path
create_secret_file() {
  local filename="$1"
  local content="$2"
  local template_path="${KUBERNETES_SECRET_TEMPLATE_SUB_PATH}.template"
  mkdir -p "$(dirname "$template_path/$filename")"
  printf '%s' "$content" > "$template_path/$filename"
}

# Helper to create a secret template file in a suffixed directory
# Note: .template is always appended as static suffix
create_secret_file_with_suffix() {
  local suffix="$1"
  local filename="$2"
  local content="$3"
  local suffixed_path="${KUBERNETES_SECRET_TEMPLATE_SUB_PATH}-${suffix}.template"
  mkdir -p "$(dirname "$suffixed_path/$filename")"
  printf '%s' "$content" > "$suffixed_path/$filename"
}

# Helper to read generated manifest
read_manifest() {
  cat "$OUTPUT_SUB_PATH/manifests/combined/secret.template.yaml"
}

# =============================================================================
# Basic functionality
# =============================================================================

@test "generates Secret template with single file" {
  create_secret_file "database-password" '${DatabasePassword}'

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"apiVersion: v1"* ]]
  [[ "$manifest" == *"kind: Secret"* ]]
  [[ "$manifest" == *"type: Opaque"* ]]
  [[ "$manifest" == *"stringData:"* ]]
  [[ "$manifest" == *"database-password:"* ]]
  [[ "$manifest" == *'${DatabasePassword}'* ]]
}

@test "generates Secret template with multiple files" {
  create_secret_file "database-password" '${DatabasePassword}'
  create_secret_file "api-key" '${ApiKey}'

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"database-password:"* ]]
  [[ "$manifest" == *"api-key:"* ]]
}

@test "type appears before metadata" {
  create_secret_file "database-password" '${DatabasePassword}'

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  # Get line numbers for type and metadata
  type_line=$(echo "$manifest" | grep -n "type: Opaque" | cut -d: -f1)
  metadata_line=$(echo "$manifest" | grep -n "^metadata:" | cut -d: -f1)
  [ "$type_line" -lt "$metadata_line" ]
}

@test "includes standard labels" {
  create_secret_file "database-password" '${DatabasePassword}'

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"labels:"* ]]
  [[ "$manifest" == *'app: ${ProjectName}'* ]]
  [[ "$manifest" == *'app.kubernetes.io/name: ${ProjectName}'* ]]
  [[ "$manifest" == *'app.kubernetes.io/version: ${Version}'* ]]
  [[ "$manifest" == *"app.kubernetes.io/managed-by: kaptain"* ]]
}

@test "includes kaptain annotations" {
  create_secret_file "database-password" '${DatabasePassword}'

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"annotations:"* ]]
  [[ "$manifest" == *'kaptain/project-name: ${ProjectName}'* ]]
  [[ "$manifest" == *'kaptain/version: ${Version}'* ]]
  [[ "$manifest" == *"kaptain/build-timestamp:"* ]]
  [[ "$manifest" == *'kaptain/generated-by: "Generated by Kaptain generate-kubernetes-secret-template feature"'* ]]
}

@test "uses checksum injection by default" {
  create_secret_file "database-password" '${DatabasePassword}'

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *'name: ${ProjectName}-secret-checksum'* ]]
}

@test "uses plain name when checksum injection disabled" {
  create_secret_file "database-password" '${DatabasePassword}'
  export KUBERNETES_SECRET_TEMPLATE_NAME_CHECKSUM_INJECTION="false"

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *'name: ${ProjectName}'* ]]
  [[ "$manifest" != *"secret-checksum"* ]]
}

@test "uses Environment token for namespace" {
  create_secret_file "database-password" '${DatabasePassword}'

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *'namespace: ${Environment}'* ]]
}

# =============================================================================
# Token style integration
# =============================================================================

@test "respects PascalCase token name style" {
  create_secret_file "database-password" '${DatabasePassword}'
  export TOKEN_NAME_STYLE="PascalCase"

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *'${ProjectName}'* ]]
  [[ "$manifest" == *'${Environment}'* ]]
}

@test "respects lower-kebab token name style" {
  create_secret_file "database-password" '${database-password}'
  export TOKEN_NAME_STYLE="lower-kebab"

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *'${project-name}'* ]]
  [[ "$manifest" == *'${environment}'* ]]
}

@test "respects UPPER_SNAKE token name style" {
  create_secret_file "database-password" '${DATABASE_PASSWORD}'
  export TOKEN_NAME_STYLE="UPPER_SNAKE"

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *'${PROJECT_NAME}'* ]]
  [[ "$manifest" == *'${ENVIRONMENT}'* ]]
}

@test "respects mustache substitution style" {
  create_secret_file "database-password" '{{ DatabasePassword }}'
  export TOKEN_DELIMITER_STYLE="mustache"

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *'{{ ProjectName }}'* ]]
  [[ "$manifest" == *'{{ Environment }}'* ]]
}

# =============================================================================
# Skip behavior
# =============================================================================

@test "exits 0 when secret template directory does not exist" {
  rm -rf "$KUBERNETES_SECRET_TEMPLATE_SUB_PATH"

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]
  assert_output_contains "not found, skipping"

  # No manifest generated
  [ ! -f "$OUTPUT_SUB_PATH/manifests/combined/secret.template.yaml" ]
}

@test "fails when secret template directory has only dotfiles" {
  # Directory exists but has only dotfiles (like .gitkeep)
  # Note: .template is always appended to the base path
  local template_path="${KUBERNETES_SECRET_TEMPLATE_SUB_PATH}.template"
  mkdir -p "$template_path"
  touch "$template_path/.gitkeep"

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 7 ]
  assert_output_contains "No files found (excluding dotfiles)"
}

# =============================================================================
# Content handling
# =============================================================================

@test "preserves multiline content" {
  create_secret_file "config" 'line1=${Value1}
line2=${Value2}
line3=${Value3}'

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *'line1=${Value1}'* ]]
  [[ "$manifest" == *'line2=${Value2}'* ]]
  [[ "$manifest" == *'line3=${Value3}'* ]]
}

@test "handles content with special characters" {
  create_secret_file "connection-string" 'postgres://${DbUser}:${DbPassword}@host:5432/db?ssl=true'

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *'postgres://${DbUser}:${DbPassword}@host:5432/db?ssl=true'* ]]
}

# =============================================================================
# Error cases
# =============================================================================

@test "fails with unknown token name style" {
  create_secret_file "database-password" '${DatabasePassword}'
  export TOKEN_NAME_STYLE="UnknownStyle"

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 2 ]
  assert_output_contains "Unknown token name style"
}

@test "fails with unknown substitution token style" {
  create_secret_file "database-password" '${DatabasePassword}'
  export TOKEN_DELIMITER_STYLE="unknown"

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 3 ]
  assert_output_contains "Unknown substitution"
}

@test "fails with invalid secret-template-name-checksum-injection value" {
  create_secret_file "database-password" '${DatabasePassword}'
  export KUBERNETES_SECRET_TEMPLATE_NAME_CHECKSUM_INJECTION="maybe"

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 4 ]
  assert_output_contains "KUBERNETES_SECRET_TEMPLATE_NAME_CHECKSUM_INJECTION must be 'true' or 'false'"
}

# =============================================================================
# Output location
# =============================================================================

@test "creates output directory if missing" {
  rm -rf "$OUTPUT_SUB_PATH"
  create_secret_file "database-password" '${DatabasePassword}'

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  [ -f "$OUTPUT_SUB_PATH/manifests/combined/secret.template.yaml" ]
}

@test "respects custom OUTPUT_SUB_PATH" {
  local custom_output=$(mktemp -d)
  export OUTPUT_SUB_PATH="$custom_output"
  create_secret_file "database-password" '${DatabasePassword}'

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  [ -f "$custom_output/manifests/combined/secret.template.yaml" ]
  rm -rf "$custom_output"
}

# =============================================================================
# Additional labels and annotations
# =============================================================================

@test "adds global additional labels" {
  create_secret_file "database-password" '${DatabasePassword}'
  export KUBERNETES_GLOBAL_ADDITIONAL_LABELS="team=platform,cost-center=123"

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"team: platform"* ]]
  [[ "$manifest" == *"cost-center: 123"* ]]
}

@test "adds secret-template-specific additional labels" {
  create_secret_file "database-password" '${DatabasePassword}'
  export KUBERNETES_SECRET_TEMPLATE_ADDITIONAL_LABELS="secret-type=credentials"

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"secret-type: credentials"* ]]
}

@test "secret-template labels override global labels" {
  create_secret_file "database-password" '${DatabasePassword}'
  export KUBERNETES_GLOBAL_ADDITIONAL_LABELS="team=global-team"
  export KUBERNETES_SECRET_TEMPLATE_ADDITIONAL_LABELS="team=secret-team"

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  manifest=$(read_manifest)
  [[ "$manifest" == *"team: secret-team"* ]]
  [[ "$manifest" != *"team: global-team"* ]]
}

# =============================================================================
# Name suffix
# =============================================================================

@test "suffix affects default sub-path" {
  # Create directory with suffix pattern: src/secret-${suffix}.template
  local suffix_dir="${KUBERNETES_SECRET_TEMPLATE_SUB_PATH%%.template}-db.template"
  mkdir -p "$suffix_dir"
  printf '${DbPassword}' > "$suffix_dir/password"

  # Unset sub-path so default is used, set suffix
  unset KUBERNETES_SECRET_TEMPLATE_SUB_PATH
  export KUBERNETES_SECRET_TEMPLATE_NAME_SUFFIX="db"

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  rm -rf "$suffix_dir"
}

@test "suffix affects metadata.name with checksum" {
  create_secret_file_with_suffix "db" "password" '${Password}'
  export KUBERNETES_SECRET_TEMPLATE_NAME_SUFFIX="db"

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  manifest=$(cat "$OUTPUT_SUB_PATH/manifests/combined/secret-db.template.yaml")
  [[ "$manifest" == *'name: ${ProjectName}-db-secret-checksum'* ]]
}

@test "suffix affects metadata.name without checksum" {
  create_secret_file_with_suffix "db" "password" '${Password}'
  export KUBERNETES_SECRET_TEMPLATE_NAME_SUFFIX="db"
  export KUBERNETES_SECRET_TEMPLATE_NAME_CHECKSUM_INJECTION="false"

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  manifest=$(cat "$OUTPUT_SUB_PATH/manifests/combined/secret-db.template.yaml")
  [[ "$manifest" == *'name: ${ProjectName}-db'* ]]
  [[ "$manifest" != *"secret-checksum"* ]]
}

@test "suffix affects output filename" {
  create_secret_file_with_suffix "db" "password" '${Password}'
  export KUBERNETES_SECRET_TEMPLATE_NAME_SUFFIX="db"

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  [ -f "$OUTPUT_SUB_PATH/manifests/combined/secret-db.template.yaml" ]
  [ ! -f "$OUTPUT_SUB_PATH/manifests/combined/secret.template.yaml" ]
}

@test "no suffix uses default filename" {
  create_secret_file "password" '${Password}'

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  [ -f "$OUTPUT_SUB_PATH/manifests/combined/secret.template.yaml" ]
}

@test "suffix appends to custom sub-path for source directory" {
  # Create a custom base path and the suffixed version with .template
  local custom_base=$(mktemp -d)
  local custom_suffixed="${custom_base}-db.template"
  mkdir -p "$custom_suffixed"
  printf '${DbPassword}' > "$custom_suffixed/password"

  # Set custom base path and suffix - should look in custom_base-db.template
  export KUBERNETES_SECRET_TEMPLATE_SUB_PATH="$custom_base"
  export KUBERNETES_SECRET_TEMPLATE_NAME_SUFFIX="db"

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  # Should have read from the suffixed directory
  manifest=$(cat "$OUTPUT_SUB_PATH/manifests/combined/secret-db.template.yaml")
  [[ "$manifest" == *"password:"* ]]
  [[ "$manifest" == *'${DbPassword}'* ]]

  rm -rf "$custom_base" "$custom_suffixed"
}

@test "custom sub-path without suffix uses path with static suffix" {
  # Create a custom path with .template suffix
  local custom_path=$(mktemp -d)
  local custom_path_template="${custom_path}.template"
  mkdir -p "$custom_path_template"
  printf '${CustomSecret}' > "$custom_path_template/secret-key"

  # Set custom path, no suffix - .template is still added
  export KUBERNETES_SECRET_TEMPLATE_SUB_PATH="$custom_path"

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  manifest=$(cat "$OUTPUT_SUB_PATH/manifests/combined/secret.template.yaml")
  [[ "$manifest" == *"secret-key:"* ]]
  [[ "$manifest" == *'${CustomSecret}'* ]]

  rm -rf "$custom_path" "$custom_path_template"
}

@test "suffix with custom sub-path affects name and filename" {
  # Create the expected suffixed path with .template
  local custom_base=$(mktemp -d)
  local custom_suffixed="${custom_base}-api.template"
  mkdir -p "$custom_suffixed"
  printf '${ApiKey}' > "$custom_suffixed/api-key"

  export KUBERNETES_SECRET_TEMPLATE_SUB_PATH="$custom_base"
  export KUBERNETES_SECRET_TEMPLATE_NAME_SUFFIX="api"

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  # Filename should include suffix
  [ -f "$OUTPUT_SUB_PATH/manifests/combined/secret-api.template.yaml" ]

  # Name should include suffix
  manifest=$(cat "$OUTPUT_SUB_PATH/manifests/combined/secret-api.template.yaml")
  [[ "$manifest" == *'name: ${ProjectName}-api-secret-checksum'* ]]

  rm -rf "$custom_base" "$custom_suffixed"
}

# =============================================================================
# Combined sub-path
# =============================================================================

@test "combined sub-path creates subdirectory in combined/" {
  create_secret_file "password" '${Password}'
  export KUBERNETES_SECRET_TEMPLATE_COMBINED_SUB_PATH="omg"

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  [ -f "$OUTPUT_SUB_PATH/manifests/combined/omg/secret.template.yaml" ]
  [ ! -f "$OUTPUT_SUB_PATH/manifests/combined/secret.template.yaml" ]
}

@test "combined sub-path affects metadata.name with checksum" {
  create_secret_file "password" '${Password}'
  export KUBERNETES_SECRET_TEMPLATE_COMBINED_SUB_PATH="omg"

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  manifest=$(cat "$OUTPUT_SUB_PATH/manifests/combined/omg/secret.template.yaml")
  [[ "$manifest" == *'name: ${ProjectName}-omg-secret-checksum'* ]]
}

@test "combined sub-path with suffix: name is ProjectName-combined-suffix-checksum" {
  create_secret_file_with_suffix "wtf" "password" '${Password}'
  export KUBERNETES_SECRET_TEMPLATE_COMBINED_SUB_PATH="omg"
  export KUBERNETES_SECRET_TEMPLATE_NAME_SUFFIX="wtf"

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  # File goes in combined sub-path directory with suffix in filename
  [ -f "$OUTPUT_SUB_PATH/manifests/combined/omg/secret-wtf.template.yaml" ]

  # Name includes both combined and suffix
  manifest=$(cat "$OUTPUT_SUB_PATH/manifests/combined/omg/secret-wtf.template.yaml")
  [[ "$manifest" == *'name: ${ProjectName}-omg-wtf-secret-checksum'* ]]
}

@test "nested combined sub-path replaces slashes with hyphens in name" {
  create_secret_file "password" '${Password}'
  export KUBERNETES_SECRET_TEMPLATE_COMBINED_SUB_PATH="omg/wtf"

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 0 ]

  [ -f "$OUTPUT_SUB_PATH/manifests/combined/omg/wtf/secret.template.yaml" ]

  manifest=$(cat "$OUTPUT_SUB_PATH/manifests/combined/omg/wtf/secret.template.yaml")
  [[ "$manifest" == *'name: ${ProjectName}-omg-wtf-secret-checksum'* ]]
}

@test "combined sub-path validation rejects uppercase" {
  create_secret_file "password" '${Password}'
  export KUBERNETES_SECRET_TEMPLATE_COMBINED_SUB_PATH="OMG"

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 5 ]
  assert_output_contains "must contain only lowercase"
}

@test "combined sub-path validation rejects leading slash" {
  create_secret_file "password" '${Password}'
  export KUBERNETES_SECRET_TEMPLATE_COMBINED_SUB_PATH="/omg"

  run "$SCRIPTS_DIR/generate-kubernetes-secret-template"
  [ "$status" -eq 6 ]
  assert_output_contains "must not start or end with a slash"
}
