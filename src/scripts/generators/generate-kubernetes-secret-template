#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025-2026 Kaptain contributors (Fred Cooke)
#
# Dedicated to Michael McCallum (@stickycode) - inspired by his project kuuty-maven-plugin
#
# generate-kubernetes-secret-template - Generates a Kubernetes Secret template from files
#
# Reads files from a directory and produces a Secret YAML manifest template with
# each file becoming a stringData entry (filename → key, content → value).
# The template contains token placeholders that are populated during deployment.
#
# Inputs (environment variables):
#   KUBERNETES_SECRET_TEMPLATE_NAME_SUFFIX - Optional suffix for name/filename (default: empty)
#   KUBERNETES_SECRET_TEMPLATE_COMBINED_SUB_PATH - Sub-path within combined/ for output (default: empty)
#   KUBERNETES_SECRET_TEMPLATE_SUB_PATH - Source directory (default: src/secret.template or src/secret-${suffix}.template)
#   OUTPUT_SUB_PATH            - Build output directory (default: target)
#   PROJECT_NAME               - Used in metadata.name (required)
#   TOKEN_NAME_STYLE           - Style for token references (default: PascalCase)
#   TOKEN_DELIMITER_STYLE      - Delimiter style for tokens (default: shell)
#   KUBERNETES_SECRET_TEMPLATE_NAME_CHECKSUM_INJECTION - Enable checksum injection suffix in name (default: true)
#   KUBERNETES_GLOBAL_ADDITIONAL_LABELS      - Extra labels for all manifests (comma-separated key=value)
#   KUBERNETES_GLOBAL_ADDITIONAL_ANNOTATIONS - Extra annotations for all manifests
#   KUBERNETES_SECRET_TEMPLATE_ADDITIONAL_LABELS   - Secret-specific extra labels
#   KUBERNETES_SECRET_TEMPLATE_ADDITIONAL_ANNOTATIONS - Secret-specific extra annotations
#
# Output:
#   ${OUTPUT_SUB_PATH}/manifests/combined/[${combined-sub-path}/]secret[-${suffix}].template.yaml
#
# metadata.name pattern:
#   ${ProjectName}[-${combined-sub-path}][-${suffix}][-secret-checksum]
#
set -euo pipefail

# Locate script directory for libraries
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="${SCRIPT_DIR}/../lib"

# Source libraries
# shellcheck source=src/scripts/lib/token-format.bash
source "${LIB_DIR}/token-format.bash"
# shellcheck source=src/scripts/lib/kubernetes-metadata.bash
source "${LIB_DIR}/kubernetes-metadata.bash"
# shellcheck source=src/scripts/lib/kubernetes-configuration.bash
source "${LIB_DIR}/kubernetes-configuration.bash"

# Logging configuration (CI-agnostic)
LOG_ERROR_PREFIX="${LOG_ERROR_PREFIX:-}"
LOG_ERROR_SUFFIX="${LOG_ERROR_SUFFIX:-}"

# Inputs with defaults
NAME_SUFFIX="${KUBERNETES_SECRET_TEMPLATE_NAME_SUFFIX:-}"
COMBINED_SUB_PATH="${KUBERNETES_SECRET_TEMPLATE_COMBINED_SUB_PATH:-}"
SOURCE_BASE_PATH="${KUBERNETES_SECRET_TEMPLATE_SUB_PATH:-src/secret.template}"
SOURCE_SUB_PATH=$(build_configuration_source_path "${SOURCE_BASE_PATH}" "${NAME_SUFFIX}" ".template")
OUTPUT_SUB_PATH="${OUTPUT_SUB_PATH:-target}"
# shellcheck source=src/scripts/defaults/tokens.bash
source "${SCRIPT_DIR}/../defaults/tokens.bash"
NAME_CHECKSUM_INJECTION="${KUBERNETES_SECRET_TEMPLATE_NAME_CHECKSUM_INJECTION:-true}"

# Validate styles upfront
validate_token_styles

if [[ "${NAME_CHECKSUM_INJECTION}" != "true" && "${NAME_CHECKSUM_INJECTION}" != "false" ]]; then
  echo "${LOG_ERROR_PREFIX}KUBERNETES_SECRET_TEMPLATE_NAME_CHECKSUM_INJECTION must be 'true' or 'false', got: ${NAME_CHECKSUM_INJECTION}${LOG_ERROR_SUFFIX}" >&2
  exit 4
fi

# Validate combined sub-path format
validate_combined_sub_path "${COMBINED_SUB_PATH}"

# Validate source directory exists and has files
validate_configuration_entries_directory "${SOURCE_SUB_PATH}" "Secret template"

# Generate token references
project_name_token=$(format_canonical_token "${TOKEN_DELIMITER_STYLE}" "${TOKEN_NAME_STYLE}" "PROJECT_NAME")
environment_token=$(format_canonical_token "${TOKEN_DELIMITER_STYLE}" "${TOKEN_NAME_STYLE}" "ENVIRONMENT")
version_token=$(format_canonical_token "${TOKEN_DELIMITER_STYLE}" "${TOKEN_NAME_STYLE}" "VERSION")

# Build metadata.name: ${ProjectName}[-${combined}][-${suffix}][-secret-checksum]
name_middle=$(build_name_middle_fragment "${COMBINED_SUB_PATH}" "${NAME_SUFFIX}")

if [[ "${NAME_CHECKSUM_INJECTION}" == "true" ]]; then
  secret_name="${project_name_token}${name_middle}-secret-checksum"
else
  secret_name="${project_name_token}${name_middle}"
fi

# Create output directory
output_dir=$(ensure_manifest_output_dir "${OUTPUT_SUB_PATH}" "${COMBINED_SUB_PATH}")

# Generate Secret template YAML (include suffix in filename if provided)
if [[ -n "${NAME_SUFFIX}" ]]; then
  output_file="${output_dir}/secret-${NAME_SUFFIX}.template.yaml"
else
  output_file="${output_dir}/secret.template.yaml"
fi

# Get current timestamp and script name for annotations
build_timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
script_name=$(basename "${BASH_SOURCE[0]}")

# Additional labels/annotations from inputs
global_labels="${KUBERNETES_GLOBAL_ADDITIONAL_LABELS:-}"
specific_labels="${KUBERNETES_SECRET_TEMPLATE_ADDITIONAL_LABELS:-}"
global_annotations="${KUBERNETES_GLOBAL_ADDITIONAL_ANNOTATIONS:-}"
specific_annotations="${KUBERNETES_SECRET_TEMPLATE_ADDITIONAL_ANNOTATIONS:-}"

{
  echo "apiVersion: v1"
  echo "kind: Secret"
  echo "type: Opaque"
  echo "metadata:"
  echo "  name: ${secret_name}"
  echo "  namespace: ${environment_token}"
  generate_metadata 2 labels
  generate_metadata 2 annotations
  echo "stringData:"
  generate_configuration_entries "${SOURCE_SUB_PATH}"
} > "${output_file}"

echo "Generated Secret template manifest: ${output_file}" >&2
echo "  Files included: ${SOURCE_FILE_COUNT}" >&2
