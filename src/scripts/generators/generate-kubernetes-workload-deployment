#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025-2026 Kaptain contributors (Fred Cooke)
#
# generate-kubernetes-workload-deployment - Generates a Kubernetes Deployment manifest
#
# Creates a complete Deployment resource with security contexts, health probes,
# resource management, volume mounts, and pod placement strategies.
#
# Called via generate-kubernetes-workload router with KUBERNETES_WORKLOAD_TYPE=deployment
#
# Inputs (environment variables):
#   Required:
#     PROJECT_NAME                          - Project identifier
#
#   Common workload settings (KUBERNETES_WORKLOAD_*):
#     See generate-kubernetes-workload for the full list of common settings
#     KUBERNETES_WORKLOAD_REPLICAS                - Replica count (default: token, "NO" for HPA)
#     KUBERNETES_WORKLOAD_REVISION_HISTORY_LIMIT  - Revision history (default: 10)
#     KUBERNETES_WORKLOAD_CONFIGMAP_KEYS_FOR_ENV  - Comma/space-separated keys to expose as env refs
#     KUBERNETES_WORKLOAD_SECRET_KEYS_FOR_ENV     - Comma/space-separated keys to expose as env refs
#
# Output:
#   ${OUTPUT_SUB_PATH}/manifests/combined/[${combined-sub-path}/]deployment[-${suffix}].yaml
#
set -euo pipefail

# Locate script directory for libraries
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="${SCRIPT_DIR}/../lib"
PLUGIN_DIR="${SCRIPT_DIR}/../plugins"

# Source libraries
# shellcheck source=src/scripts/lib/token-format.bash
source "${LIB_DIR}/token-format.bash"
# shellcheck source=src/scripts/lib/kubernetes-metadata.bash
source "${LIB_DIR}/kubernetes-metadata.bash"
# shellcheck source=src/scripts/lib/kubernetes-configuration.bash
source "${LIB_DIR}/kubernetes-configuration.bash"
# shellcheck source=src/scripts/lib/kubernetes-probes.bash
source "${LIB_DIR}/kubernetes-probes.bash"
# shellcheck source=src/scripts/lib/kubernetes-workload-detection.bash
source "${LIB_DIR}/kubernetes-workload-detection.bash"
# shellcheck source=src/scripts/lib/kubernetes-pod-spec.bash
source "${LIB_DIR}/kubernetes-pod-spec.bash"

# Logging configuration (CI-agnostic)
LOG_ERROR_PREFIX="${LOG_ERROR_PREFIX:-}"
LOG_ERROR_SUFFIX="${LOG_ERROR_SUFFIX:-}"

# =============================================================================
# Inputs with defaults
# =============================================================================

# Naming and paths (common workload settings)
NAME_SUFFIX="${KUBERNETES_WORKLOAD_NAME_SUFFIX:-}"
COMBINED_SUB_PATH="${KUBERNETES_WORKLOAD_COMBINED_SUB_PATH:-}"
ENV_BASE_PATH="${KUBERNETES_WORKLOAD_ENV_SUB_PATH:-src/deployment-env}"
ENV_SUB_PATH=$(build_configuration_source_path "${ENV_BASE_PATH}" "${NAME_SUFFIX}" "-env")

# shellcheck source=src/scripts/defaults/common.bash
source "${SCRIPT_DIR}/../defaults/common.bash"
# shellcheck source=src/scripts/defaults/tokens.bash
source "${SCRIPT_DIR}/../defaults/tokens.bash"
# shellcheck source=src/scripts/defaults/kubernetes-workload.bash
source "${SCRIPT_DIR}/../defaults/kubernetes-workload.bash"

# =============================================================================
# Validation
# =============================================================================

# Validate required inputs
if [[ -z "${PROJECT_NAME:-}" ]]; then
  echo "${LOG_ERROR_PREFIX}PROJECT_NAME is required${LOG_ERROR_SUFFIX}" >&2
  exit 1
fi

# Validate styles
validate_token_styles

# Validate seccomp profile
if [[ "${SECCOMP_PROFILE}" != "DISABLED" && "${SECCOMP_PROFILE}" != "RuntimeDefault" && "${SECCOMP_PROFILE}" != "Localhost" && "${SECCOMP_PROFILE}" != "Unconfined" ]]; then
  echo "${LOG_ERROR_PREFIX}KUBERNETES_WORKLOAD_SECCOMP_PROFILE must be 'DISABLED', 'RuntimeDefault', 'Localhost', or 'Unconfined', got: ${SECCOMP_PROFILE}${LOG_ERROR_SUFFIX}" >&2
  exit 4
fi

# Validate readonly root filesystem
if [[ "${READONLY_ROOT_FILESYSTEM}" != "true" && "${READONLY_ROOT_FILESYSTEM}" != "false" ]]; then
  echo "${LOG_ERROR_PREFIX}KUBERNETES_WORKLOAD_READONLY_ROOT_FILESYSTEM must be 'true' or 'false', got: ${READONLY_ROOT_FILESYSTEM}${LOG_ERROR_SUFFIX}" >&2
  exit 4
fi

# Validate image reference style
if [[ "${IMAGE_REFERENCE_STYLE}" != "combined" && "${IMAGE_REFERENCE_STYLE}" != "separate" && "${IMAGE_REFERENCE_STYLE}" != "project-name-prefixed-combined" && "${IMAGE_REFERENCE_STYLE}" != "project-name-prefixed-separate" ]]; then
  echo "${LOG_ERROR_PREFIX}KUBERNETES_WORKLOAD_IMAGE_REFERENCE_STYLE must be 'combined', 'separate', 'project-name-prefixed-combined', or 'project-name-prefixed-separate', got: ${IMAGE_REFERENCE_STYLE}${LOG_ERROR_SUFFIX}" >&2
  exit 4
fi

# Validate combined sub-path format
validate_combined_sub_path "${COMBINED_SUB_PATH}"

# Validate affinity strategy plugin exists
affinity_strategy="${AFFINITY_STRATEGY}"
affinity_plugin="${PLUGIN_DIR}/pod-placement-strategy/${affinity_strategy}"
if [[ ! -x "${affinity_plugin}" ]]; then
  echo "${LOG_ERROR_PREFIX}Unknown affinity strategy '${affinity_strategy}' - plugin not found at ${affinity_plugin}${LOG_ERROR_SUFFIX}" >&2
  exit 5
fi

# =============================================================================
# Generate token references
# =============================================================================

project_name_token=$(format_canonical_token "${TOKEN_DELIMITER_STYLE}" "${TOKEN_NAME_STYLE}" "PROJECT_NAME")
environment_token=$(format_canonical_token "${TOKEN_DELIMITER_STYLE}" "${TOKEN_NAME_STYLE}" "ENVIRONMENT")
version_token=$(format_canonical_token "${TOKEN_DELIMITER_STYLE}" "${TOKEN_NAME_STYLE}" "VERSION")
docker_tag_token=$(format_canonical_token "${TOKEN_DELIMITER_STYLE}" "${TOKEN_NAME_STYLE}" "DOCKER_TAG")
docker_image_name_token=$(format_canonical_token "${TOKEN_DELIMITER_STYLE}" "${TOKEN_NAME_STYLE}" "DOCKER_IMAGE_NAME")

# Image reference tokens - depends on style
# imagePullSecrets uses the registry token matching the style (what you auth against)
case "${IMAGE_REFERENCE_STYLE}" in
  combined)
    registry_and_base_token=$(format_canonical_token "${TOKEN_DELIMITER_STYLE}" "${TOKEN_NAME_STYLE}" "ENVIRONMENT_DOCKER_REGISTRY_AND_BASE_PATH")
    image_reference="${registry_and_base_token}/${docker_image_name_token}:${docker_tag_token}"
    image_pull_secret_token=$(format_canonical_token "${TOKEN_DELIMITER_STYLE}" "${TOKEN_NAME_STYLE}" "ENVIRONMENT_DOCKER_REGISTRY")
    ;;
  separate)
    docker_registry_token=$(format_canonical_token "${TOKEN_DELIMITER_STYLE}" "${TOKEN_NAME_STYLE}" "ENVIRONMENT_DOCKER_REGISTRY")
    docker_base_path_token=$(format_canonical_token "${TOKEN_DELIMITER_STYLE}" "${TOKEN_NAME_STYLE}" "ENVIRONMENT_DOCKER_BASE_PATH")
    image_reference="${docker_registry_token}/${docker_base_path_token}/${docker_image_name_token}:${docker_tag_token}"
    image_pull_secret_token="${docker_registry_token}"
    ;;
  project-name-prefixed-combined)
    registry_and_base_token=$(format_canonical_token "${TOKEN_DELIMITER_STYLE}" "${TOKEN_NAME_STYLE}" "PROJECT_NAME_ENVIRONMENT_DOCKER_REGISTRY_AND_BASE_PATH")
    image_reference="${registry_and_base_token}/${docker_image_name_token}:${docker_tag_token}"
    image_pull_secret_token=$(format_canonical_token "${TOKEN_DELIMITER_STYLE}" "${TOKEN_NAME_STYLE}" "PROJECT_NAME_ENVIRONMENT_DOCKER_REGISTRY")
    ;;
  project-name-prefixed-separate)
    docker_registry_token=$(format_canonical_token "${TOKEN_DELIMITER_STYLE}" "${TOKEN_NAME_STYLE}" "PROJECT_NAME_ENVIRONMENT_DOCKER_REGISTRY")
    docker_base_path_token=$(format_canonical_token "${TOKEN_DELIMITER_STYLE}" "${TOKEN_NAME_STYLE}" "PROJECT_NAME_ENVIRONMENT_DOCKER_BASE_PATH")
    image_reference="${docker_registry_token}/${docker_base_path_token}/${docker_image_name_token}:${docker_tag_token}"
    image_pull_secret_token="${docker_registry_token}"
    ;;
esac

# Replicas: empty → default token, "NO" → omit for HPA, other → pass through (numeric or custom token)
default_replicas_token=$(format_canonical_token "${TOKEN_DELIMITER_STYLE}" "${TOKEN_NAME_STYLE}" "ENVIRONMENT_DEFAULT_REPLICA_COUNT")
if [[ -z "${REPLICAS}" ]]; then
  resolved_replicas="${default_replicas_token}"
elif [[ "${REPLICAS}" == "NO" ]]; then
  resolved_replicas="NO"
else
  resolved_replicas="${REPLICAS}"
fi

# =============================================================================
# Build metadata.name
# =============================================================================

name_middle=$(build_name_middle_fragment "${COMBINED_SUB_PATH}" "${NAME_SUFFIX}")
deployment_name="${project_name_token}${name_middle}"

# =============================================================================
# Create output directory and file
# =============================================================================

output_dir=$(ensure_manifest_output_dir "${OUTPUT_SUB_PATH}" "${COMBINED_SUB_PATH}")

if [[ -n "${NAME_SUFFIX}" ]]; then
  output_file="${output_dir}/deployment-${NAME_SUFFIX}.yaml"
else
  output_file="${output_dir}/deployment.yaml"
fi

# =============================================================================
# Detect optional resources
# =============================================================================

detect_all_resources

# =============================================================================
# Diagnostic output
# =============================================================================

echo "Strategy/Mode Selections" >&2
echo "  Affinity strategy:        ${AFFINITY_STRATEGY}" >&2
echo "  Readonly root filesystem: ${READONLY_ROOT_FILESYSTEM}" >&2
echo "  Seccomp profile:          ${SECCOMP_PROFILE}" >&2
echo "  Liveness probe:           ${LIVENESS_CHECK_TYPE}" >&2
echo "  Readiness probe:          ${READINESS_CHECK_TYPE}" >&2
echo "  Startup probe:            ${STARTUP_CHECK_TYPE}" >&2

echo "Detection Results" >&2
if [[ "${has_configmap}" == "true" ]]; then
  echo "  ConfigMap detected:       ${configmap_source}" >&2
else
  echo "  ConfigMap detected:       No, so won't be mounted" >&2
fi
if [[ "${has_secret}" == "true" ]]; then
  echo "  Secret detected:          ${secret_source}" >&2
else
  echo "  Secret detected:          No, so won't be mounted" >&2
fi
if [[ "${has_serviceaccount}" == "true" ]]; then
  echo "  ServiceAccount detected:  ${serviceaccount_source}" >&2
else
  echo "  ServiceAccount detected:  No, so implicit default used" >&2
fi
if [[ "${has_env_vars}" == "true" ]]; then
  echo "  Environment variables:    ${env_file_count} found" >&2
else
  echo "  Environment variables:    None found, not configured" >&2
fi

echo "Conditional Fields" >&2
if [[ "${resolved_replicas}" == "NO" ]]; then
  echo "  Replicas:                 managed by HPA" >&2
else
  echo "  Replicas:                 ${resolved_replicas}" >&2
fi
if [[ -n "${CPU_LIMIT}" ]]; then
  echo "  CPU limit:                ${CPU_LIMIT}" >&2
else
  echo "  CPU limit:                Not set, so no throttling" >&2
fi
if [[ -n "${PRESTOP_COMMAND}" ]]; then
  echo "  PreStop hook:             configured" >&2
else
  echo "  PreStop hook:             not configured" >&2
fi

# =============================================================================
# Build labels and annotations
# =============================================================================

build_timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
script_name=$(basename "${BASH_SOURCE[0]}")

# Additional labels/annotations from inputs (common workload settings)
global_labels="${KUBERNETES_GLOBAL_ADDITIONAL_LABELS:-}"
specific_labels="${KUBERNETES_WORKLOAD_ADDITIONAL_LABELS:-}"
global_annotations="${KUBERNETES_GLOBAL_ADDITIONAL_ANNOTATIONS:-}"
specific_annotations="${KUBERNETES_WORKLOAD_ADDITIONAL_ANNOTATIONS:-}"

# =============================================================================
# Generate Deployment YAML
# =============================================================================

{
  # Header
  generate_manifest_header "apps/v1" "Deployment" "${deployment_name}" "${environment_token}"
  generate_metadata 2 labels
  generate_metadata 2 annotations default-app

  # Spec
  echo "spec:"

  # Replicas (omit if NO for HPA)
  if [[ "${resolved_replicas}" != "NO" ]]; then
    echo "  replicas: ${resolved_replicas}"
  fi

  echo "  revisionHistoryLimit: ${REVISION_HISTORY_LIMIT}"

  # Selector
  echo "  selector:"
  echo "    matchLabels:"
  echo "      app: ${project_name_token}"

  # Update strategy (fixed - zero downtime)
  echo "  strategy:"
  echo "    type: RollingUpdate"
  echo "    rollingUpdate:"
  echo "      maxSurge: 1"
  echo "      maxUnavailable: 0"

  # Pod template
  echo "  template:"
  echo "    metadata:"
  generate_metadata 6 labels
  generate_metadata 6 annotations

  echo "    spec:"

  # ServiceAccount
  generate_service_account_config 6 "${has_serviceaccount}" "${project_name_token}${suffix_fragment}" "${AUTOMOUNT_SERVICE_ACCOUNT_TOKEN}"

  # Termination grace period
  echo "      terminationGracePeriodSeconds: ${TERMINATION_GRACE_PERIOD_SECONDS}"

  # Pod security context
  generate_pod_security_context 6 "${SECCOMP_PROFILE}"

  # Affinity (via plugin)
  if [[ "${affinity_strategy}" != "none" ]]; then
    POD_PLACEMENT_INDENT=6 \
    TOKEN_NAME_STYLE="${TOKEN_NAME_STYLE}" \
    TOKEN_DELIMITER_STYLE="${TOKEN_DELIMITER_STYLE}" \
    PROJECT_NAME="${PROJECT_NAME}" \
    "${affinity_plugin}"
  fi

  # Image pull secrets (optional)
  if [[ "${IMAGE_PULL_SECRETS}" != "DISABLED" ]]; then
    generate_image_pull_secrets 6 "${image_pull_secret_token}"
  fi

  # Containers
  echo "      containers:"
  generate_container_start 8 "default-app" "${image_reference}"

  # Ports
  generate_container_ports 10 "${CONTAINER_PORT}"

  # Container security context
  generate_container_security_context 10 "${READONLY_ROOT_FILESYSTEM}"

  # Resources
  generate_container_resources 10 "${EPHEMERAL_STORAGE}" "${MEMORY}" "${CPU_REQUEST}" "${CPU_LIMIT}"

  # Lifecycle (preStop hook)
  generate_container_lifecycle 10 "${PRESTOP_COMMAND}"

  # Probes
  generate_workload_probes 10

  # Environment variables (plain KVs from directory + refs from configmap/secret keys)
  generate_container_env_all 10 "${ENV_SUB_PATH}" \
    "${configmap_source}" "${project_name_token}${suffix_fragment}-configmap-checksum" "${CONFIGMAP_KEYS_FOR_ENV}" \
    "${secret_source}" "${project_name_token}${suffix_fragment}-secret-checksum" "${SECRET_KEYS_FOR_ENV}"

  # Volume mounts
  generate_configmap_secret_volume_mounts 10 "${has_configmap}" "${has_secret}" "${CONFIGMAP_MOUNT_PATH}" "${SECRET_MOUNT_PATH}"

  # Volumes
  generate_configmap_secret_volumes 6 "${has_configmap}" "${has_secret}" "${project_name_token}${suffix_fragment}-configmap-checksum" "${project_name_token}${suffix_fragment}-secret-checksum"

} > "${output_file}"

echo "Generated Deployment manifest: ${output_file}" >&2
