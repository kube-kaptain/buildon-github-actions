#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025 Kaptain contributors (Fred Cooke)
#
# versions-and-naming - Generates versions, tags, and naming
#
# Outputs:
#   RELEASE_TAG   - Numeric version (e.g., 1.2.3)
#   DOCKER_TAG    - Same as RELEASE_TAG on release branch, suffixed otherwise
#   IS_RELEASE    - "true" if on release branch, "false" otherwise
#   PROJECT_NAME  - Repository name
#
set -euo pipefail

# Configuration with defaults
DEFAULT_BRANCH="${DEFAULT_BRANCH:-main}"
PATCH_BRANCHES="${PATCH_BRANCHES:-}"  # Comma-separated list of patch branch patterns
MAX_VERSION_PARTS="${MAX_VERSION_PARTS:-3}"  # Fail if version exceeds this many parts

# Get current branch
get_current_branch() {
  git rev-parse --abbrev-ref HEAD
}

# Get repository name
get_project_name() {
  basename "$(git rev-parse --show-toplevel)"
}

# Check if current branch is a release branch
is_release_branch() {
  local current_branch="$1"

  # Check if it's the default branch
  if [[ "$current_branch" == "$DEFAULT_BRANCH" ]]; then
    return 0
  fi

  # Check if it matches any patch branch pattern
  if [[ -n "$PATCH_BRANCHES" ]]; then
    IFS=',' read -ra patterns <<< "$PATCH_BRANCHES"
    for pattern in "${patterns[@]}"; do
      # shellcheck disable=SC2053
      if [[ "$current_branch" == $pattern ]]; then
        return 0
      fi
    done
  fi

  return 1
}

# Check if a tag is annotated (heavy) vs lightweight
is_annotated_tag() {
  local tag="$1"
  local obj_type
  obj_type=$(git cat-file -t "refs/tags/$tag" 2>/dev/null)
  [[ "$obj_type" == "tag" ]]
}

# Find the most recent tag in history (determines our series)
# Primary sort: distance from HEAD (closest wins)
# Tiebreaker: creation date (newest wins)
# Only considers annotated (heavy) tags
find_recent_tag() {
  local tag distance creatordate
  local best_tag="" best_distance=999999 best_date=0

  # Get all annotated tags reachable from HEAD
  for tag in $(git tag --merged HEAD 2>/dev/null); do
    if is_annotated_tag "$tag"; then
      # Calculate distance from HEAD
      distance=$(git rev-list --count "$tag"..HEAD)
      # Get creation date as Unix timestamp
      creatordate=$(git for-each-ref --format='%(creatordate:unix)' "refs/tags/$tag")

      # Pick this tag if:
      # - It's closer (smaller distance), OR
      # - Same distance but newer creation date
      if [[ $distance -lt $best_distance ]] || \
         [[ $distance -eq $best_distance && $creatordate -gt $best_date ]]; then
        best_tag="$tag"
        best_distance=$distance
        best_date=$creatordate
      fi
    fi
  done

  if [[ -n "$best_tag" ]]; then
    echo "$best_tag"
  fi
}

# Get version prefix (all but last component)
get_version_prefix() {
  local version="$1"
  version="${version#v}"

  # Remove last component to get prefix
  if [[ "$version" == *.* ]]; then
    echo "${version%.*}"
  else
    # Single component version, no prefix
    echo ""
  fi
}

# Check if a tag is a pure numeric version (no -rc1, -beta, etc)
is_numeric_version() {
  local tag="$1"
  tag="${tag#v}"
  # Must be only digits and dots, with at least one dot
  [[ "$tag" =~ ^[0-9]+(\.[0-9]+)+$ ]]
}

# Find highest tag in a series across entire repo
find_highest_in_series() {
  local recent_tag="$1"

  if [[ -z "$recent_tag" ]]; then
    echo ""
    return
  fi

  local prefix
  prefix=$(get_version_prefix "$recent_tag")

  if [[ -z "$prefix" ]]; then
    # Single component version, just return the recent tag
    echo "$recent_tag"
    return
  fi

  # Get ALL tags in repo (not just reachable from HEAD)
  # Filter to those matching our prefix with pure numeric versions only
  # This excludes tags like 1.2.3-rc1, 1.2.3-beta, etc
  local highest
  highest=$(git tag --list | while read -r tag; do
    # Strip v prefix for comparison
    local clean="${tag#v}"
    # Must start with our prefix, followed by dot and digits only
    if [[ "$clean" =~ ^${prefix}\.[0-9]+$ ]] && is_numeric_version "$tag"; then
      echo "$tag"
    fi
  done | sort -t. -k1,1n -k2,2n -k3,3n -k4,4n -k5,5n | tail -n1)

  if [[ -z "$highest" ]]; then
    # No matching tags found, use the recent tag
    echo "$recent_tag"
  else
    echo "$highest"
  fi
}

# Parse version into components
parse_version() {
  local version="$1"
  # Remove any 'v' prefix
  version="${version#v}"
  echo "$version"
}

# Count parts in a version string
count_version_parts() {
  local version="$1"
  version="${version#v}"
  local dot_count
  dot_count=$(echo "$version" | tr -cd '.' | wc -c | tr -d ' ')
  echo $((dot_count + 1))
}

# Pad or truncate version to exactly N parts
version_to_n_parts() {
  local version="$1"
  local n="$2"
  version="${version#v}"

  IFS='.' read -ra parts <<< "$version"
  local current_parts=${#parts[@]}

  # Build result with exactly n parts
  local result=""
  for ((i=0; i<n; i++)); do
    if [[ $i -gt 0 ]]; then
      result+="."
    fi
    if [[ $i -lt $current_parts ]]; then
      result+="${parts[$i]}"
    else
      result+="0"
    fi
  done

  echo "$result"
}

# Increment version - always increments last component
increment_version() {
  local current="$1"

  if [[ -z "$current" ]]; then
    # No existing tag, start at 1.0.0
    echo "1.0.0"
    return
  fi

  # Remove 'v' prefix if present
  current="${current#v}"

  # Split version into array and increment last part
  IFS='.' read -ra parts <<< "$current"
  local last_idx=$((${#parts[@]} - 1))
  parts[last_idx]=$((parts[last_idx] + 1))
  local IFS='.'
  echo "${parts[*]}"
}

# Push tag to remote
push_tag() {
  local tag="$1"
  git config user.email "noreply@kaptain.org"
  git config user.name "Kube Kaptain"
  git tag -m "Automatic release tag by Kaptain build script." "$tag" HEAD
  git push origin "$tag"
}

# Output variable for GitHub Actions
output_var() {
  local name="$1"
  local value="$2"

  echo "${name}=${value}"

  # If running in GitHub Actions, set output
  if [[ -n "${GITHUB_OUTPUT:-}" ]]; then
    echo "${name}=${value}" >> "$GITHUB_OUTPUT"
  fi

  # Also export for downstream scripts
  export "${name}=${value}"
}

main() {
  local current_branch
  current_branch=$(get_current_branch)

  local project_name
  project_name=$(get_project_name)

  # Step 1: Find most recent tag to determine our series
  local recent_tag
  recent_tag=$(find_recent_tag)

  # Step 2: Find highest tag in that series across entire repo
  local highest_tag
  highest_tag=$(find_highest_in_series "$recent_tag")

  # Step 3: Increment the highest
  local new_version
  new_version=$(increment_version "$highest_tag")

  # Step 4: Validate against MAX_VERSION_PARTS
  local part_count
  part_count=$(count_version_parts "$new_version")
  if [[ $part_count -gt $MAX_VERSION_PARTS ]]; then
    echo "::error::Version '$new_version' has $part_count parts, exceeds MAX_VERSION_PARTS=$MAX_VERSION_PARTS" >&2
    exit 1
  fi

  local is_release="false"
  local docker_tag

  if is_release_branch "$current_branch"; then
    is_release="true"
    docker_tag="$new_version"

    # Push the tag on release branches
    echo "Tagging release: $new_version" >&2
    push_tag "$new_version"
  else
    docker_tag="${new_version}-PRERELEASE"
    echo "Pre-release build: $docker_tag (no tag push)" >&2
  fi

  # Generate padded/truncated versions for different ecosystems
  local version_2_part version_3_part version_4_part
  version_2_part=$(version_to_n_parts "$new_version" 2)
  version_3_part=$(version_to_n_parts "$new_version" 3)
  version_4_part=$(version_to_n_parts "$new_version" 4)

  # Extract individual parts (major.minor.patch...)
  local clean_version="${new_version#v}"
  IFS='.' read -ra version_parts <<< "$clean_version"
  local version_major="${version_parts[0]:-0}"
  local version_minor="${version_parts[1]:-0}"
  local version_patch="${version_parts[2]:-0}"

  # Generate docker image name: prefix/full-name (e.g., my/my-project-sucks)
  local docker_image_name
  local prefix="${project_name%%-*}"
  docker_image_name="${prefix}/${project_name}"

  output_var "VERSION" "$new_version"
  output_var "VERSION_MAJOR" "$version_major"
  output_var "VERSION_MINOR" "$version_minor"
  output_var "VERSION_PATCH" "$version_patch"
  output_var "VERSION_2_PART" "$version_2_part"
  output_var "VERSION_3_PART" "$version_3_part"
  output_var "VERSION_4_PART" "$version_4_part"
  output_var "DOCKER_TAG" "$docker_tag"
  output_var "DOCKER_IMAGE_NAME" "$docker_image_name"
  output_var "IS_RELEASE" "$is_release"
  output_var "PROJECT_NAME" "$project_name"
}

main "$@"
