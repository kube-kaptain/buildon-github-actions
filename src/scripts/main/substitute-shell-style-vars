#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025 Kaptain contributors (Fred Cooke)
#
# substitute-shell-style-vars - Substitutes multiple shell-style ${VAR} variables in files
#
# This script is DUMB - it loops over variables and calls substitute-shell-style-var for each.
# No case conversion, no intelligence. Caller is responsible for translating variable names
# to the desired case style before calling this script.
#
# Inputs (environment variables):
#   VARIABLES    - Comma-separated name=value pairs (names already in target case style)
#   INPUT_PATH   - File or directory to process (required)
#   OUTPUT_PATH  - Where to write results (required, must differ from INPUT_PATH)
#
# Outputs (stdout):
#   Substitution statistics (file:vars:lines format, one per line)
#
# Example:
#   VARIABLES="project-name=my-app,version=1.2.3"
#   INPUT_PATH="src/kubernetes"
#   OUTPUT_PATH="target/substituted"
#
set -euo pipefail

# Locate script directory for calling sibling scripts
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PLUGINS_DIR="$SCRIPT_DIR/../plugins"

# Logging configuration (CI-agnostic)
LOG_ERROR_PREFIX="${LOG_ERROR_PREFIX:-}"
LOG_ERROR_SUFFIX="${LOG_ERROR_SUFFIX:-}"

# Required inputs
VARIABLES="${VARIABLES:?VARIABLES is required (comma-separated name=value pairs)}"
INPUT_PATH="${INPUT_PATH:?INPUT_PATH is required}"
OUTPUT_PATH="${OUTPUT_PATH:?OUTPUT_PATH is required}"

# Validate paths differ
if [[ "$INPUT_PATH" == "$OUTPUT_PATH" ]]; then
  echo "${LOG_ERROR_PREFIX}INPUT_PATH and OUTPUT_PATH must differ${LOG_ERROR_SUFFIX}" >&2
  exit 1
fi

# Validate input exists
if [[ ! -e "$INPUT_PATH" ]]; then
  echo "${LOG_ERROR_PREFIX}Input path not found: $INPUT_PATH${LOG_ERROR_SUFFIX}" >&2
  exit 1
fi

main() {
  # Parse VARIABLES and process each one
  local first_var=true

  # Split by comma and parse each pair
  IFS=',' read -ra pairs <<< "$VARIABLES"

  if [[ ${#pairs[@]} -eq 0 ]]; then
    echo "${LOG_ERROR_PREFIX}No variables parsed from VARIABLES${LOG_ERROR_SUFFIX}" >&2
    exit 1
  fi

  for pair in "${pairs[@]}"; do
    # Split by first = only
    local var_name="${pair%%=*}"
    local var_value="${pair#*=}"

    if [[ -z "$var_name" ]]; then
      echo "${LOG_ERROR_PREFIX}Invalid variable format: $pair${LOG_ERROR_SUFFIX}" >&2
      exit 1
    fi

    if [[ "$first_var" == "true" ]]; then
      # First variable: read from INPUT_PATH, write to OUTPUT_PATH
      VAR_NAME="$var_name" \
      VAR_VALUE="$var_value" \
      INPUT_PATH="$INPUT_PATH" \
      OUTPUT_PATH="$OUTPUT_PATH" \
      LOG_ERROR_PREFIX="$LOG_ERROR_PREFIX" \
      LOG_ERROR_SUFFIX="$LOG_ERROR_SUFFIX" \
      "$PLUGINS_DIR/variable-substitution-providers/substitute-shell-style-var" > /dev/null

      first_var=false
    else
      # Subsequent variables: read from OUTPUT_PATH, write to temp, then move back
      local temp_location

      if [[ -f "$OUTPUT_PATH" ]]; then
        # For files: create a temp file
        temp_location=$(mktemp)

        VAR_NAME="$var_name" \
        VAR_VALUE="$var_value" \
        INPUT_PATH="$OUTPUT_PATH" \
        OUTPUT_PATH="$temp_location" \
        LOG_ERROR_PREFIX="$LOG_ERROR_PREFIX" \
        LOG_ERROR_SUFFIX="$LOG_ERROR_SUFFIX" \
        "$PLUGINS_DIR/variable-substitution-providers/substitute-shell-style-var" > /dev/null

        # Move result back
        mv "$temp_location" "$OUTPUT_PATH"
      else
        # For directories: create a temp directory
        temp_location=$(mktemp -d)

        VAR_NAME="$var_name" \
        VAR_VALUE="$var_value" \
        INPUT_PATH="$OUTPUT_PATH" \
        OUTPUT_PATH="$temp_location" \
        LOG_ERROR_PREFIX="$LOG_ERROR_PREFIX" \
        LOG_ERROR_SUFFIX="$LOG_ERROR_SUFFIX" \
        "$PLUGINS_DIR/variable-substitution-providers/substitute-shell-style-var" > /dev/null

        # Move results back to OUTPUT_PATH
        rm -rf "$OUTPUT_PATH"
        mv "$temp_location" "$OUTPUT_PATH"
      fi
    fi
  done

  # Count substitutions and lines modified by comparing before/after
  # Note: grep -c returns 1 when no matches found, so we use a helper
  count_tokens() {
    local file="$1"
    local count
    count=$(grep -c '\${' "$file" 2>/dev/null) || count=0
    echo "$count"
  }

  # Count lines that differ between two files
  count_lines_changed() {
    local file1="$1"
    local file2="$2"
    local diff_output count
    # diff exits 1 when files differ (not an error), so capture output separately
    diff_output=$(diff "$file1" "$file2" 2>/dev/null) || true
    count=$(echo "$diff_output" | grep -c '^[<>]') || count=0
    # Each change has a < and > line, so divide by 2 for actual lines changed
    echo $((count / 2))
  }

  # Output stats for a single file pair
  output_file_stats() {
    local input_file="$1"
    local output_file="$2"
    local display_name="$3"

    local before_count after_count vars_subbed lines_changed
    before_count=$(count_tokens "$input_file")
    after_count=$(count_tokens "$output_file")
    vars_subbed=$((before_count - after_count))
    lines_changed=$(count_lines_changed "$input_file" "$output_file")

    if [[ $vars_subbed -gt 0 ]]; then
      echo "$display_name:$vars_subbed:$lines_changed"
    fi
  }

  if [[ -f "$INPUT_PATH" ]]; then
    output_file_stats "$INPUT_PATH" "$OUTPUT_PATH" "$(basename "$OUTPUT_PATH")"
  elif [[ -d "$INPUT_PATH" ]]; then
    while IFS= read -r input_file; do
      local rel_path="${input_file#$INPUT_PATH/}"
      local output_file="$OUTPUT_PATH/$rel_path"

      if [[ -f "$output_file" ]]; then
        output_file_stats "$input_file" "$output_file" "$rel_path"
      fi
    done < <(find "$INPUT_PATH" -type f)
  fi
}

main "$@"
