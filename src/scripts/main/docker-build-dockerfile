#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025-2026 Kaptain contributors (Fred Cooke)
#
# docker-build-dockerfile - Builds a Docker image from a Dockerfile
#
# Copies Dockerfile directory to build output, applies token substitution,
# then builds from the substituted copy. This allows using variables like
# ${TargetRegistry}/${TargetNamespace}/base-image:1.0.0 in Dockerfiles.
#
# Build only - does not push. Workflow handles push after optional test step.
# This separation allows injecting test steps between build and push.
#
# Single-platform mode (default): builds one image with the base tag.
# Multi-platform mode (comma-separated DOCKER_PLATFORM): builds per-platform
# images with arch-suffixed tags, registers manifest-uris for push-all.
#
# Inputs (environment variables):
# System generated:
#   DOCKER_IMAGE_NAME        - Image name (from version generator)
#   DOCKER_TAG               - Tag for the image (from version generator)
#   VERSION             - Version number (from version generator, passed as build arg)
#   PROJECT_NAME        - Project name (from version generator, passed as build arg)
# User set inputs (validate):
#   DOCKER_TARGET_REGISTRY   - Container registry (e.g., ghcr.io)
#   DOCKER_TARGET_NAMESPACE   - Namespace between registry and image name (optional)
#   DOCKERFILE_SUB_PATH - Directory containing Dockerfile, relative (default: src/docker)
#   OUTPUT_SUB_PATH     - Build output directory, relative (default: target)
#   DOCKERFILE_SQUASH   - Squash mode: squash, squash-all, or no (default: squash)
#   IMAGE_BUILD_COMMAND - Container runtime: podman or docker (from validate-tooling)
#   BUILD_MODE          - "local" for lenient dev builds, "build_server" for strict (default: build_server)
#   DOCKERFILE_NO_CACHE - "false" to enable layer caching (default: true, always build fresh)
#   TOKEN_DELIMITER_STYLE - Token delimiter syntax (default: shell)
#   TOKEN_NAME_STYLE    - Case style for token names (default: PascalCase)
#   TOKEN_NAME_VALIDATION - How to validate user token names (default: MATCH)
#   ALLOW_BUILTIN_TOKEN_OVERRIDE - Allow user tokens to override built-ins (default: false)
#   CONFIG_SUB_PATH     - Source directory for user-defined tokens, relative (default: src/config)
#   CONFIG_VALUE_TRAILING_NEWLINE - Trailing newline handling (default: strip-for-single-line)
#   DOCKER_PLATFORM     - Target platform (default: linux/amd64, or comma-separated for multi)
# Multi-platform inputs:
#   DOCKERFILE_SUB_PATH_LINUX_AMD64 - Per-platform source dir (default: src/docker-linux-amd64)
#   DOCKERFILE_SUB_PATH_LINUX_ARM64 - Per-platform source dir (default: src/docker-linux-arm64)
#   DOCKER_CONTEXT_SUB_PATH_LINUX_AMD64 - Per-platform context dir
#   DOCKER_CONTEXT_SUB_PATH_LINUX_ARM64 - Per-platform context dir
#
# Outputs:
#   DOCKER_TARGET_IMAGE_FULL_URI - Full image reference (base URI, for use in push step)
#
set -euo pipefail

# Locate script directory for calling sibling scripts
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Logging configuration (CI-agnostic)
LOG_ERROR_PREFIX="${LOG_ERROR_PREFIX:-}"
LOG_ERROR_SUFFIX="${LOG_ERROR_SUFFIX:-}"
LOG_WARNING_PREFIX="${LOG_WARNING_PREFIX:-}"
LOG_WARNING_SUFFIX="${LOG_WARNING_SUFFIX:-}"

# Apply defaults for inputs used directly in this script
# shellcheck source=src/scripts/defaults/output-sub-path.bash
source "${SCRIPT_DIR}/../defaults/output-sub-path.bash"
# shellcheck source=src/scripts/defaults/build-mode.bash
source "${SCRIPT_DIR}/../defaults/build-mode.bash"
# shellcheck source=src/scripts/defaults/docker-common.bash
source "${SCRIPT_DIR}/../defaults/docker-common.bash"
# shellcheck source=src/scripts/defaults/docker-build.bash
source "${SCRIPT_DIR}/../defaults/docker-build.bash"
# shellcheck source=src/scripts/defaults/docker-dockerfile.bash
source "${SCRIPT_DIR}/../defaults/docker-dockerfile.bash"
# shellcheck source=src/scripts/defaults/docker-push-image-list.bash
source "${SCRIPT_DIR}/../defaults/docker-push-image-list.bash"
# shellcheck source=src/scripts/defaults/tokens.bash
source "${SCRIPT_DIR}/../defaults/tokens.bash"
# shellcheck source=src/scripts/lib/output-var.bash
source "${SCRIPT_DIR}/../lib/output-var.bash"

# === Shared target validation, URI assembly, and utilities ===
# shellcheck source=src/scripts/lib/docker-build-shared.bash
source "${SCRIPT_DIR}/../lib/docker-build-shared.bash"

# Required inputs (DOCKER_TAG validated in shared script)
VERSION="${VERSION:?VERSION is required}"
PROJECT_NAME="${PROJECT_NAME:?PROJECT_NAME is required}"

# Build output structure (sub-paths, relative to working directory)
DOCKER_CONFIG_SUB_PATH="${OUTPUT_SUB_PATH}/docker/config"

# build_for_platform - Copies, substitutes, and builds for a single platform
#
# Used once in single-platform mode, once per arch in multi-platform mode.
#
# Args:
#   $1 - platform (e.g., linux/amd64)
#   $2 - source_dir (Dockerfile source directory)
#   $3 - context_dir (build context output directory)
#   $4 - config_dir (substitution tokens output directory)
#   $5 - image_uri (full image URI including tag)
build_for_platform() {
  local platform="$1"
  local source_dir="$2"
  local context_dir="$3"
  local config_dir="$4"
  local image_uri="$5"

  # Copy source directory to build context (if it exists)
  mkdir -p "${context_dir}"
  if [[ ! -d "${source_dir}" ]]; then
    echo "${LOG_WARNING_PREFIX}Dockerfile directory not found: ${source_dir} (final context dir may be populated by hook)${LOG_WARNING_SUFFIX}" >&2
  else
    # Validate Dockerfile case in source (case-sensitive check for case-insensitive filesystems)
    local wrong_case=""
    for f in "${source_dir}"/*; do
      [[ -f "${f}" ]] || continue
      local name
      name=$(basename "${f}")
      if [[ "${name}" != "Dockerfile" ]] && [[ "$(echo "${name}" | tr '[:upper:]' '[:lower:]')" == "dockerfile" ]]; then
        wrong_case="${name}"
      fi
    done
    if [[ -n "${wrong_case}" ]]; then
      echo "${LOG_ERROR_PREFIX}Dockerfile has wrong case: found '${wrong_case}' but must be exactly 'Dockerfile'${LOG_ERROR_SUFFIX}" >&2
      exit 1
    fi

    echo "" >&2
    echo "Copying docker directory for substitution..." >&2
    local file_count
    file_count=$(find "${source_dir}" -type f | wc -l | tr -d ' ')
    if [[ "${file_count}" -gt 0 ]]; then
      cp -R "${source_dir}/." "${context_dir}/"
      echo "Copied ${file_count} file(s) to ${context_dir}" >&2
    else
      echo "${LOG_WARNING_PREFIX}No files in ${source_dir} (final context dir may be populated by hook)${LOG_WARNING_SUFFIX}" >&2
    fi
  fi

  # Confirm target doesn't exist before building (fail fast)
  if ${IMAGE_BUILD_COMMAND} manifest inspect "${image_uri}" &>/dev/null; then
    echo "${LOG_ERROR_PREFIX}Target image already exists in registry: ${image_uri}${LOG_ERROR_SUFFIX}" >&2
    exit 1
  fi
  echo "Confirmed target image does not exist in registry: ${image_uri}" >&2

  # Fail if no Dockerfile in context dir (neither from source nor from hook)
  if [[ ! -f "${context_dir}/Dockerfile" ]]; then
    echo "${LOG_ERROR_PREFIX}Dockerfile not found in build context: ${context_dir} (not in ${source_dir} and not provided by hook)${LOG_ERROR_SUFFIX}" >&2
    exit 1
  fi

  # Prepare substitution tokens (built-ins + user config)
  echo "" >&2
  TOKENS_OUTPUT_SUB_PATH="${config_dir}" \
  CONFIG_SUB_PATH="${CONFIG_SUB_PATH}" \
  TOKEN_NAME_STYLE="${TOKEN_NAME_STYLE}" \
  TOKEN_NAME_VALIDATION="${TOKEN_NAME_VALIDATION}" \
  ALLOW_BUILTIN_TOKEN_OVERRIDE="${ALLOW_BUILTIN_TOKEN_OVERRIDE}" \
  CONFIG_VALUE_TRAILING_NEWLINE="${CONFIG_VALUE_TRAILING_NEWLINE}" \
  PROJECT_NAME="${PROJECT_NAME}" \
  VERSION="${VERSION}" \
  DOCKER_TAG="${DOCKER_TAG}" \
  DOCKER_IMAGE_NAME="${DOCKER_IMAGE_NAME}" \
  DOCKER_IMAGE_FULL_URI="${image_uri}" \
  TARGET_REGISTRY="${TARGET_REGISTRY}" \
  TARGET_NAMESPACE="${TARGET_NAMESPACE}" \
  "${SCRIPT_DIR}/../util/prepare-substitution-tokens"

  # Perform variable substitution on specific files only
  echo "" >&2
  if [[ -n "${DOCKERFILE_SUBSTITUTION_FILES}" ]]; then
    echo "Performing variable substitution on: ${DOCKERFILE_SUBSTITUTION_FILES}" >&2
    IFS=',' read -ra sub_files <<< "${DOCKERFILE_SUBSTITUTION_FILES}"
    for sub_file in "${sub_files[@]}"; do
      local target_file="${context_dir}/${sub_file}"
      if [[ -f "${target_file}" ]]; then
        CONFIG_VALUE_TRAILING_NEWLINE="${CONFIG_VALUE_TRAILING_NEWLINE}" \
        "${SCRIPT_DIR}/../util/substitute-tokens-from-dir" \
          "${TOKEN_DELIMITER_STYLE}" \
          "${config_dir}" \
          "${target_file}"
      else
        echo "${LOG_WARNING_PREFIX}Substitution target not found, skipping: ${sub_file}${LOG_WARNING_SUFFIX}" >&2
      fi
    done
  else
    echo "No substitution files specified, skipping token substitution" >&2
  fi

  # Build from substituted directory
  local dockerfile="${context_dir}/Dockerfile"
  local cmd=("${IMAGE_BUILD_COMMAND}" build --platform "${platform}" -f "${dockerfile}" -t "${image_uri}")

  # Add standard build args (Dockerfile can use or ignore)
  cmd+=(--build-arg "VERSION=${VERSION}")
  cmd+=(--build-arg "PROJECT_NAME=${PROJECT_NAME}")

  # Add standard labels (injected at build time, no Dockerfile changes needed)
  local build_datetime
  build_datetime=$(date -u +%Y-%m-%dT%H:%M:%SZ)
  cmd+=(--label "version=${DOCKER_TAG}")
  cmd+=(--label "image.name=${DOCKER_IMAGE_NAME}")
  cmd+=(--label "build.datetime=${build_datetime}")

  # Add squash flag (podman supports --squash and --squash-all natively)
  if [[ "${DOCKERFILE_SQUASH}" != "no" ]]; then
    cmd+=("--${DOCKERFILE_SQUASH}")
  fi

  # Disable layer caching by default for reproducible builds
  if [[ "${DOCKERFILE_NO_CACHE}" == "true" ]]; then
    cmd+=(--no-cache)
  fi

  # Add context
  cmd+=("${context_dir}")

  echo "" >&2
  echo "Building: ${cmd[*]}" >&2

  # Capture build output for post-build validation
  local platform_suffix="${platform//\//-}"
  local BUILD_OUTPUT="${OUTPUT_SUB_PATH}/docker-build-output-${platform_suffix}.log"
  local BUILD_EXIT=0
  "${cmd[@]}" 2>&1 | tee "${BUILD_OUTPUT}" || BUILD_EXIT=${PIPESTATUS[0]}

  if [[ ${BUILD_EXIT} -ne 0 ]]; then
    echo "${LOG_ERROR_PREFIX}Docker build failed for ${platform} (exit ${BUILD_EXIT})${LOG_ERROR_SUFFIX}" >&2
    exit "${BUILD_EXIT}"
  fi
}

main() {
  echo "=== Docker Build Dockerfile ===" >&2
  echo "Target: ${TARGET_IMAGE_FULL_URI}" >&2
  echo "Platform: ${DOCKER_PLATFORM}" >&2
  echo "Dockerfile sub-path: ${DOCKERFILE_SUB_PATH}" >&2
  echo "Output sub-path: ${OUTPUT_SUB_PATH}" >&2
  echo "Squash: ${DOCKERFILE_SQUASH}" >&2
  echo "Token style: ${TOKEN_DELIMITER_STYLE}" >&2
  echo "Name style: ${TOKEN_NAME_STYLE}" >&2
  echo "===============================" >&2

  # Validate squash value
  case "${DOCKERFILE_SQUASH}" in
    squash|squash-all|no) ;;
    *)
      echo "${LOG_ERROR_PREFIX}Invalid DOCKERFILE_SQUASH value '${DOCKERFILE_SQUASH}' - must be: squash, squash-all, or no${LOG_ERROR_SUFFIX}" >&2
      exit 1
      ;;
  esac

  # Squash handling
  if [[ "${DOCKERFILE_SQUASH}" != "no" ]]; then
    if [[ "${IMAGE_BUILD_COMMAND}" == "docker" ]]; then
      if [[ "${BUILD_MODE}" == "build_server" ]]; then
        echo "${LOG_ERROR_PREFIX}Squash requested but docker 29+ does not support it - podman is required on build server${LOG_ERROR_SUFFIX}" >&2
        exit 1
      else
        echo "${LOG_WARNING_PREFIX}Squash requested but docker 29+ does not support it - forcing no squash${LOG_WARNING_SUFFIX}" >&2
        DOCKERFILE_SQUASH="no"
      fi
    fi
  fi

  if [[ "${DOCKER_PLATFORM}" == *,* ]]; then
    # === Multi-platform build ===
    IFS=',' read -ra platforms <<< "${DOCKER_PLATFORM}"
    local manifest_uris_file="${OUTPUT_SUB_PATH}/docker-push-all/manifest-uris"
    mkdir -p "$(dirname "${manifest_uris_file}")"

    for platform in "${platforms[@]}"; do
      local platform_suffix="${platform//\//-}"
      local source_dir context_dir config_dir arch_uri

      case "${platform}" in
        linux/amd64)
          source_dir="${DOCKERFILE_SUB_PATH_LINUX_AMD64}"
          context_dir="${DOCKER_CONTEXT_SUB_PATH_LINUX_AMD64}"
          config_dir="${OUTPUT_SUB_PATH}/docker-linux-amd64/config"
          ;;
        linux/arm64)
          source_dir="${DOCKERFILE_SUB_PATH_LINUX_ARM64}"
          context_dir="${DOCKER_CONTEXT_SUB_PATH_LINUX_ARM64}"
          config_dir="${OUTPUT_SUB_PATH}/docker-linux-arm64/config"
          ;;
        *)
          echo "${LOG_ERROR_PREFIX}Unsupported platform in multi-platform build: ${platform}${LOG_ERROR_SUFFIX}" >&2
          exit 1
          ;;
      esac

      arch_uri="${TARGET_IMAGE_FULL_URI}-${platform_suffix}"

      echo "" >&2
      echo "--- Building for ${platform} (${arch_uri}) ---" >&2
      build_for_platform "${platform}" "${source_dir}" "${context_dir}" "${config_dir}" "${arch_uri}"

      # Register arch-specific image for consolidated push
      echo "${arch_uri}" >> "${DOCKER_PUSH_IMAGE_LIST_FILE}"
    done

    # Register base URI for manifest list creation
    echo "${TARGET_IMAGE_FULL_URI}" >> "${manifest_uris_file}"

    output_var "DOCKER_TARGET_IMAGE_FULL_URI" "${TARGET_IMAGE_FULL_URI}"
  else
    # === Single-platform build ===
    build_for_platform "${DOCKER_PLATFORM}" "${DOCKERFILE_SUB_PATH}" "${DOCKER_CONTEXT_SUB_PATH}" "${DOCKER_CONFIG_SUB_PATH}" "${TARGET_IMAGE_FULL_URI}"

    output_var "DOCKER_TARGET_IMAGE_FULL_URI" "${TARGET_IMAGE_FULL_URI}"

    # Register image for consolidated push
    echo "${TARGET_IMAGE_FULL_URI}" >> "${DOCKER_PUSH_IMAGE_LIST_FILE}"
  fi

  echo "" >&2
  echo "Docker Build Dockerfile complete" >&2
}

main "$@"
