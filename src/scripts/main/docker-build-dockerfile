#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025-2026 Kaptain contributors (Fred Cooke)
#
# docker-build-dockerfile - Builds a Docker image from a Dockerfile
#
# Copies Dockerfile directory to build output, applies token substitution,
# then builds from the substituted copy. This allows using variables like
# ${TargetRegistry}/${TargetNamespace}/base-image:1.0.0 in Dockerfiles.
#
# Build only - does not push. Workflow handles push after optional test step.
# This separation allows injecting test steps between build and push.
#
# Inputs (environment variables):
# System generated:
#   DOCKER_IMAGE_NAME        - Image name (from version generator)
#   DOCKER_TAG               - Tag for the image (from version generator)
#   VERSION             - Version number (from version generator, passed as build arg)
#   PROJECT_NAME        - Project name (from version generator, passed as build arg)
# User set inputs (validate):
#   DOCKER_TARGET_REGISTRY   - Container registry (e.g., ghcr.io)
#   DOCKER_TARGET_NAMESPACE   - Namespace between registry and image name (optional)
#   DOCKERFILE_SUB_PATH - Directory containing Dockerfile, relative (default: src/docker)
#   OUTPUT_SUB_PATH     - Build output directory, relative (default: target)
#   DOCKERFILE_SQUASH   - Squash mode: squash, squash-all, or no (default: squash)
#   IMAGE_BUILD_COMMAND - Container runtime: podman or docker (from validate-tooling)
#   BUILD_MODE          - "local" for lenient dev builds, "build_server" for strict (default: build_server)
#   DOCKERFILE_NO_CACHE - "false" to enable layer caching (default: true, always build fresh)
#   TOKEN_DELIMITER_STYLE - Token delimiter syntax (default: shell)
#   TOKEN_NAME_STYLE    - Case style for token names (default: PascalCase)
#   TOKEN_NAME_VALIDATION - How to validate user token names (default: MATCH)
#   ALLOW_BUILTIN_TOKEN_OVERRIDE - Allow user tokens to override built-ins (default: false)
#   CONFIG_SUB_PATH     - Source directory for user-defined tokens, relative (default: src/config)
#   CONFIG_VALUE_TRAILING_NEWLINE - Trailing newline handling (default: strip-for-single-line)
#
# Outputs:
#   DOCKER_TARGET_IMAGE_FULL_URI - Full image reference (for use in push step)
#
set -euo pipefail

# Locate script directory for calling sibling scripts
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Logging configuration (CI-agnostic)
LOG_ERROR_PREFIX="${LOG_ERROR_PREFIX:-}"
LOG_ERROR_SUFFIX="${LOG_ERROR_SUFFIX:-}"
LOG_WARNING_PREFIX="${LOG_WARNING_PREFIX:-}"
LOG_WARNING_SUFFIX="${LOG_WARNING_SUFFIX:-}"

# Apply defaults for inputs used directly in this script
# shellcheck source=src/scripts/defaults/output-sub-path.bash
source "${SCRIPT_DIR}/../defaults/output-sub-path.bash"
# shellcheck source=src/scripts/defaults/build-mode.bash
source "${SCRIPT_DIR}/../defaults/build-mode.bash"
# shellcheck source=src/scripts/defaults/docker-common.bash
source "${SCRIPT_DIR}/../defaults/docker-common.bash"
# shellcheck source=src/scripts/defaults/docker-build.bash
source "${SCRIPT_DIR}/../defaults/docker-build.bash"
# shellcheck source=src/scripts/defaults/docker-dockerfile.bash
source "${SCRIPT_DIR}/../defaults/docker-dockerfile.bash"
# shellcheck source=src/scripts/defaults/docker-push-image-list.bash
source "${SCRIPT_DIR}/../defaults/docker-push-image-list.bash"
# shellcheck source=src/scripts/defaults/tokens.bash
source "${SCRIPT_DIR}/../defaults/tokens.bash"
# shellcheck source=src/scripts/lib/output-var.bash
source "${SCRIPT_DIR}/../lib/output-var.bash"

# === Shared target validation, URI assembly, and utilities ===
# shellcheck source=src/scripts/lib/docker-build-shared.bash
source "${SCRIPT_DIR}/../lib/docker-build-shared.bash"

# Required inputs (DOCKER_TAG validated in shared script)
VERSION="${VERSION:?VERSION is required}"
PROJECT_NAME="${PROJECT_NAME:?PROJECT_NAME is required}"

# Build output structure (sub-paths, relative to working directory)
DOCKER_CONFIG_SUB_PATH="${OUTPUT_SUB_PATH}/docker/config"

main() {
  echo "=== Docker Build Dockerfile ===" >&2
  echo "Target: ${TARGET_IMAGE_FULL_URI}" >&2
  echo "Dockerfile sub-path: ${DOCKERFILE_SUB_PATH}" >&2
  echo "Output sub-path: ${OUTPUT_SUB_PATH}" >&2
  echo "Squash: ${DOCKERFILE_SQUASH}" >&2
  echo "Token style: ${TOKEN_DELIMITER_STYLE}" >&2
  echo "Name style: ${TOKEN_NAME_STYLE}" >&2
  echo "===============================" >&2

  # Copy source directory to build context (if it exists)
  mkdir -p "${DOCKER_CONTEXT_SUB_PATH}"
  if [[ ! -d "${DOCKERFILE_SUB_PATH}" ]]; then
    echo "${LOG_WARNING_PREFIX}Dockerfile directory not found: ${DOCKERFILE_SUB_PATH} (final context dir may be populated by hook)${LOG_WARNING_SUFFIX}" >&2
  else
    # Validate Dockerfile case in source (case-sensitive check for case-insensitive filesystems)
    local wrong_case=""
    for f in "${DOCKERFILE_SUB_PATH}"/*; do
      [[ -f "${f}" ]] || continue
      local name
      name=$(basename "${f}")
      if [[ "${name}" != "Dockerfile" ]] && [[ "$(echo "${name}" | tr '[:upper:]' '[:lower:]')" == "dockerfile" ]]; then
        wrong_case="${name}"
      fi
    done
    if [[ -n "${wrong_case}" ]]; then
      echo "${LOG_ERROR_PREFIX}Dockerfile has wrong case: found '${wrong_case}' but must be exactly 'Dockerfile'${LOG_ERROR_SUFFIX}" >&2
      exit 1
    fi

    echo "" >&2
    echo "Copying docker directory for substitution..." >&2
    local file_count
    file_count=$(find "${DOCKERFILE_SUB_PATH}" -type f | wc -l | tr -d ' ')
    if [[ "${file_count}" -gt 0 ]]; then
      cp -R "${DOCKERFILE_SUB_PATH}"/* "${DOCKER_CONTEXT_SUB_PATH}/"
      echo "Copied ${file_count} file(s) to ${DOCKER_CONTEXT_SUB_PATH}" >&2
    else
      echo "${LOG_WARNING_PREFIX}No files in ${DOCKERFILE_SUB_PATH} (final context dir may be populated by hook)${LOG_WARNING_SUFFIX}" >&2
    fi
  fi

  # Confirm target doesn't exist before building (fail fast)
  confirm_target_image_doesnt_exist || exit 1

  # Fail if no Dockerfile in context dir (neither from source nor from hook)
  if [[ ! -f "${DOCKER_CONTEXT_SUB_PATH}/Dockerfile" ]]; then
    echo "${LOG_ERROR_PREFIX}Dockerfile not found in build context: ${DOCKER_CONTEXT_SUB_PATH} (not in ${DOCKERFILE_SUB_PATH} and not provided by hook)${LOG_ERROR_SUFFIX}" >&2
    exit 1
  fi

  # Prepare substitution tokens (built-ins + user config)
  echo "" >&2
  TOKENS_OUTPUT_SUB_PATH="${DOCKER_CONFIG_SUB_PATH}" \
  CONFIG_SUB_PATH="${CONFIG_SUB_PATH}" \
  TOKEN_NAME_STYLE="${TOKEN_NAME_STYLE}" \
  TOKEN_NAME_VALIDATION="${TOKEN_NAME_VALIDATION}" \
  ALLOW_BUILTIN_TOKEN_OVERRIDE="${ALLOW_BUILTIN_TOKEN_OVERRIDE}" \
  CONFIG_VALUE_TRAILING_NEWLINE="${CONFIG_VALUE_TRAILING_NEWLINE}" \
  PROJECT_NAME="${PROJECT_NAME}" \
  VERSION="${VERSION}" \
  DOCKER_TAG="${DOCKER_TAG}" \
  DOCKER_IMAGE_NAME="${DOCKER_IMAGE_NAME}" \
  DOCKER_IMAGE_FULL_URI="${TARGET_IMAGE_FULL_URI}" \
  TARGET_REGISTRY="${TARGET_REGISTRY}" \
  TARGET_NAMESPACE="${TARGET_NAMESPACE}" \
  "${SCRIPT_DIR}/../util/prepare-substitution-tokens"

  # Perform variable substitution on specific files only
  echo "" >&2
  if [[ -n "${DOCKERFILE_SUBSTITUTION_FILES}" ]]; then
    echo "Performing variable substitution on: ${DOCKERFILE_SUBSTITUTION_FILES}" >&2
    IFS=',' read -ra sub_files <<< "${DOCKERFILE_SUBSTITUTION_FILES}"
    for sub_file in "${sub_files[@]}"; do
      local target_file="${DOCKER_CONTEXT_SUB_PATH}/${sub_file}"
      if [[ -f "${target_file}" ]]; then
        CONFIG_VALUE_TRAILING_NEWLINE="${CONFIG_VALUE_TRAILING_NEWLINE}" \
        "${SCRIPT_DIR}/../util/substitute-tokens-from-dir" \
          "${TOKEN_DELIMITER_STYLE}" \
          "${DOCKER_CONFIG_SUB_PATH}" \
          "${target_file}"
      else
        echo "${LOG_WARNING_PREFIX}Substitution target not found, skipping: ${sub_file}${LOG_WARNING_SUFFIX}" >&2
      fi
    done
  else
    echo "No substitution files specified, skipping token substitution" >&2
  fi

  # Build from substituted directory
  local dockerfile="${DOCKER_CONTEXT_SUB_PATH}/Dockerfile"

  # Validate squash value
  case "${DOCKERFILE_SQUASH}" in
    squash|squash-all|no) ;;
    *)
      echo "${LOG_ERROR_PREFIX}Invalid DOCKERFILE_SQUASH value '${DOCKERFILE_SQUASH}' - must be: squash, squash-all, or no${LOG_ERROR_SUFFIX}" >&2
      exit 1
      ;;
  esac

  # Squash handling
  if [[ "${DOCKERFILE_SQUASH}" != "no" ]]; then
    if [[ "${IMAGE_BUILD_COMMAND}" == "docker" ]]; then
      if [[ "${BUILD_MODE}" == "build_server" ]]; then
        echo "${LOG_ERROR_PREFIX}Squash requested but docker 29+ does not support it - podman is required on build server${LOG_ERROR_SUFFIX}" >&2
        exit 1
      else
        echo "${LOG_WARNING_PREFIX}Squash requested but docker 29+ does not support it - forcing no squash${LOG_WARNING_SUFFIX}" >&2
        DOCKERFILE_SQUASH="no"
      fi
    fi
  fi

  # Build command
  local cmd=("${IMAGE_BUILD_COMMAND}" build -f "${dockerfile}" -t "${TARGET_IMAGE_FULL_URI}")

  # Add standard build args (Dockerfile can use or ignore)
  cmd+=(--build-arg "VERSION=${VERSION}")
  cmd+=(--build-arg "PROJECT_NAME=${PROJECT_NAME}")

  # Add standard labels (injected at build time, no Dockerfile changes needed)
  local build_datetime
  build_datetime=$(date -u +%Y-%m-%dT%H:%M:%SZ)
  cmd+=(--label "version=${DOCKER_TAG}")
  cmd+=(--label "image.name=${DOCKER_IMAGE_NAME}")
  cmd+=(--label "build.datetime=${build_datetime}")

  # Add squash flag (podman supports --squash and --squash-all natively)
  if [[ "${DOCKERFILE_SQUASH}" != "no" ]]; then
    cmd+=("--${DOCKERFILE_SQUASH}")
  fi

  # Disable layer caching by default for reproducible builds
  if [[ "${DOCKERFILE_NO_CACHE}" == "true" ]]; then
    cmd+=(--no-cache)
  fi

  # Add context
  cmd+=("${DOCKER_CONTEXT_SUB_PATH}")

  echo "" >&2
  echo "Building: ${cmd[*]}" >&2

  # Capture build output for post-build validation
  local BUILD_OUTPUT="${OUTPUT_SUB_PATH}/docker-build-output.log"
  local BUILD_EXIT=0
  "${cmd[@]}" 2>&1 | tee "${BUILD_OUTPUT}" || BUILD_EXIT=${PIPESTATUS[0]}

  if [[ ${BUILD_EXIT} -ne 0 ]]; then
    echo "${LOG_ERROR_PREFIX}Docker build failed (exit ${BUILD_EXIT})${LOG_ERROR_SUFFIX}" >&2
    exit "${BUILD_EXIT}"
  fi

  output_var "DOCKER_TARGET_IMAGE_FULL_URI" "${TARGET_IMAGE_FULL_URI}"

  # Register image for consolidated push
  echo "${TARGET_IMAGE_FULL_URI}" >> "${DOCKER_PUSH_IMAGE_LIST_FILE}"

  echo "" >&2
  echo "Docker Build Dockerfile complete" >&2
}

main "$@"
