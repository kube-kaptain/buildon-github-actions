#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025 Kaptain contributors (Fred Cooke)
#
# docker-build-dockerfile - Builds a Docker image from a Dockerfile
#
# Copies Dockerfile directory to build output, applies token substitution,
# then builds from the substituted copy. This allows using variables like
# ${TargetRegistry}/${TargetBasePath}/base-image:1.0.0 in Dockerfiles.
#
# Build only - does not push. Workflow handles push after optional test step.
# This separation allows injecting test steps between build and push.
#
# Inputs (environment variables):
#   TARGET_REGISTRY     - Container registry (e.g., ghcr.io)
#   TARGET_BASE_PATH    - Path between registry and image name (optional)
#   TARGET_IMAGE_NAME   - Image name (from version generator)
#   DOCKER_TAG          - Tag for the image (from version generator)
#   VERSION             - Version number (from version generator, passed as build arg)
#   PROJECT_NAME        - Project name (from version generator, passed as build arg)
#   DOCKERFILE_SUB_PATH - Directory containing Dockerfile, relative (default: src/docker)
#   OUTPUT_SUB_PATH     - Build output directory, relative (default: target)
#   SQUASH              - "false" to disable --squash (default: true, always squash for clean D files)
#   NO_CACHE            - "false" to enable layer caching (default: true, always build fresh)
#   SUBSTITUTION_TOKEN_STYLE - Token delimiter syntax (default: shell)
#   TOKEN_NAME_STYLE    - Case style for token names (default: PascalCase)
#   TOKEN_NAME_VALIDATION - How to validate user token names (default: MATCH)
#   ALLOW_BUILTIN_TOKEN_OVERRIDE - Allow user tokens to override built-ins (default: false)
#   CONFIG_SUB_PATH     - Source directory for user-defined tokens, relative (default: src/config)
#   CONFIG_VALUE_TRAILING_NEWLINE - Trailing newline handling (default: strip-for-single-line)
#
# Outputs:
#   DOCKER_TARGET_IMAGE_FULL_URI - Full image reference (for use in push step)
#
set -euo pipefail

# Locate script directory for calling sibling scripts
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Logging configuration (CI-agnostic)
LOG_ERROR_PREFIX="${LOG_ERROR_PREFIX:-}"
LOG_ERROR_SUFFIX="${LOG_ERROR_SUFFIX:-}"

# Required inputs
TARGET_REGISTRY="${TARGET_REGISTRY:?TARGET_REGISTRY is required}"
TARGET_IMAGE_NAME="${TARGET_IMAGE_NAME:?TARGET_IMAGE_NAME is required}"
DOCKER_TAG="${DOCKER_TAG:?DOCKER_TAG is required}"
VERSION="${VERSION:?VERSION is required}"
PROJECT_NAME="${PROJECT_NAME:?PROJECT_NAME is required}"

# Optional inputs with defaults
TARGET_BASE_PATH="${TARGET_BASE_PATH:-}"
DOCKERFILE_SUB_PATH="${DOCKERFILE_SUB_PATH:-src/docker}"
OUTPUT_SUB_PATH="${OUTPUT_SUB_PATH:-target}"
SQUASH="${SQUASH:-true}"
NO_CACHE="${NO_CACHE:-true}"
SUBSTITUTION_TOKEN_STYLE="${SUBSTITUTION_TOKEN_STYLE:-shell}"
TOKEN_NAME_STYLE="${TOKEN_NAME_STYLE:-PascalCase}"
TOKEN_NAME_VALIDATION="${TOKEN_NAME_VALIDATION:-MATCH}"
ALLOW_BUILTIN_TOKEN_OVERRIDE="${ALLOW_BUILTIN_TOKEN_OVERRIDE:-false}"
CONFIG_SUB_PATH="${CONFIG_SUB_PATH:-src/config}"
CONFIG_VALUE_TRAILING_NEWLINE="${CONFIG_VALUE_TRAILING_NEWLINE:-strip-for-single-line}"

# Build output structure (sub-paths, relative to working directory)
DOCKER_CONFIG_SUB_PATH="${OUTPUT_SUB_PATH}/docker/config"
DOCKER_SUBSTITUTED_SUB_PATH="${OUTPUT_SUB_PATH}/docker/substituted"

# Assemble full image URI
if [[ -n "${TARGET_BASE_PATH}" ]]; then
  TARGET_IMAGE_FULL_URI="${TARGET_REGISTRY}/${TARGET_BASE_PATH}/${TARGET_IMAGE_NAME}:${DOCKER_TAG}"
else
  TARGET_IMAGE_FULL_URI="${TARGET_REGISTRY}/${TARGET_IMAGE_NAME}:${DOCKER_TAG}"
fi

confirm_image_doesnt_exist() {
  local image="${1}"

  if docker manifest inspect "${image}" &>/dev/null; then
    echo "${LOG_ERROR_PREFIX}Target image already exists in registry: ${image}${LOG_ERROR_SUFFIX}" >&2
    return 1
  fi

  echo "Confirmed image does not exist in registry (safe to build and push)" >&2
  return 0
}

enable_experimental() {
  # Enable Docker experimental features for --squash
  echo "Enabling Docker experimental mode for --squash" >&2
  sudo mkdir -p /etc/docker
  echo '{"experimental": true}' | sudo tee /etc/docker/daemon.json > /dev/null
  sudo systemctl restart docker
  # Wait for Docker to be ready
  local retries=10
  while ! docker info &>/dev/null && [[ ${retries} -gt 0 ]]; do
    sleep 1
    ((retries--))
  done
  if ! docker info &>/dev/null; then
    echo "${LOG_ERROR_PREFIX}Docker failed to restart after enabling experimental mode${LOG_ERROR_SUFFIX}" >&2
    return 1
  fi
  echo "Docker experimental mode enabled" >&2
}

output_var() {
  local name="${1}"
  local value="${2}"

  echo "${name}=${value}"

  if [[ -n "${GITHUB_OUTPUT:-}" ]]; then
    echo "${name}=${value}" >> "${GITHUB_OUTPUT}"
  fi
}

main() {
  echo "=== Docker Build Dockerfile ===" >&2
  echo "Target: ${TARGET_IMAGE_FULL_URI}" >&2
  echo "Dockerfile sub-path: ${DOCKERFILE_SUB_PATH}" >&2
  echo "Output sub-path: ${OUTPUT_SUB_PATH}" >&2
  echo "Squash: ${SQUASH}" >&2
  echo "Token style: ${SUBSTITUTION_TOKEN_STYLE}" >&2
  echo "Name style: ${TOKEN_NAME_STYLE}" >&2
  echo "===============================" >&2

  # Validate source directory exists
  if [[ ! -d "${DOCKERFILE_SUB_PATH}" ]]; then
    echo "${LOG_ERROR_PREFIX}Dockerfile directory not found: ${DOCKERFILE_SUB_PATH}${LOG_ERROR_SUFFIX}" >&2
    exit 1
  fi

  # Validate Dockerfile exists with exact name (case-sensitive check)
  # Loop through files to verify exact case (works on case-insensitive filesystems)
  local exact_match=false
  local wrong_case=""
  for f in "${DOCKERFILE_SUB_PATH}"/*; do
    [[ -f "${f}" ]] || continue
    local name
    name=$(basename "${f}")
    if [[ "${name}" == "Dockerfile" ]]; then
      exact_match=true
      break
    elif [[ "$(echo "${name}" | tr '[:upper:]' '[:lower:]')" == "dockerfile" ]]; then
      wrong_case="${name}"
    fi
  done

  if [[ "${exact_match}" != "true" ]]; then
    if [[ -n "${wrong_case}" ]]; then
      echo "${LOG_ERROR_PREFIX}Dockerfile has wrong case: found '${wrong_case}' but must be exactly 'Dockerfile'${LOG_ERROR_SUFFIX}" >&2
    else
      echo "${LOG_ERROR_PREFIX}Dockerfile not found in: ${DOCKERFILE_SUB_PATH}${LOG_ERROR_SUFFIX}" >&2
    fi
    exit 1
  fi

  # Confirm target doesn't exist before building (fail fast)
  confirm_image_doesnt_exist "${TARGET_IMAGE_FULL_URI}" || exit 1

  # Copy docker directory to build output for substitution
  echo "" >&2
  echo "Copying docker directory for substitution..." >&2
  mkdir -p "${DOCKER_SUBSTITUTED_SUB_PATH}"
  cp -R "${DOCKERFILE_SUB_PATH}"/* "${DOCKER_SUBSTITUTED_SUB_PATH}/"

  # Count files copied
  local file_count
  file_count=$(find "${DOCKER_SUBSTITUTED_SUB_PATH}" -type f | wc -l | tr -d ' ')
  echo "Copied ${file_count} file(s) to ${DOCKER_SUBSTITUTED_SUB_PATH}" >&2

  # Prepare substitution tokens (built-ins + user config)
  echo "" >&2
  TOKENS_OUTPUT_SUB_PATH="${DOCKER_CONFIG_SUB_PATH}" \
  CONFIG_SUB_PATH="${CONFIG_SUB_PATH}" \
  TOKEN_NAME_STYLE="${TOKEN_NAME_STYLE}" \
  TOKEN_NAME_VALIDATION="${TOKEN_NAME_VALIDATION}" \
  ALLOW_BUILTIN_TOKEN_OVERRIDE="${ALLOW_BUILTIN_TOKEN_OVERRIDE}" \
  CONFIG_VALUE_TRAILING_NEWLINE="${CONFIG_VALUE_TRAILING_NEWLINE}" \
  PROJECT_NAME="${PROJECT_NAME}" \
  VERSION="${VERSION}" \
  DOCKER_TAG="${DOCKER_TAG}" \
  DOCKER_IMAGE_NAME="${TARGET_IMAGE_NAME}" \
  DOCKER_IMAGE_FULL_URI="${TARGET_IMAGE_FULL_URI}" \
  TARGET_REGISTRY="${TARGET_REGISTRY}" \
  TARGET_BASE_PATH="${TARGET_BASE_PATH}" \
  "${SCRIPT_DIR}/prepare-substitution-tokens"

  # Perform variable substitution on copied docker directory
  echo "" >&2
  echo "Performing variable substitution..." >&2
  CONFIG_VALUE_TRAILING_NEWLINE="${CONFIG_VALUE_TRAILING_NEWLINE}" \
  "${SCRIPT_DIR}/substitute-tokens-from-dir" \
    "${SUBSTITUTION_TOKEN_STYLE}" \
    "${DOCKER_CONFIG_SUB_PATH}" \
    "${DOCKER_SUBSTITUTED_SUB_PATH}"

  # Build from substituted directory
  local dockerfile="${DOCKER_SUBSTITUTED_SUB_PATH}/Dockerfile"
  local context="${DOCKER_SUBSTITUTED_SUB_PATH}"

  # Enable experimental mode if squash requested
  if [[ "${SQUASH}" == "true" ]]; then
    enable_experimental
    # Disable BuildKit - it doesn't support --squash (just warns and builds fat images)
    export DOCKER_BUILDKIT=0
  fi

  # Build command
  local cmd=(docker build -f "${dockerfile}" -t "${TARGET_IMAGE_FULL_URI}")

  # Add standard build args (Dockerfile can use or ignore)
  cmd+=(--build-arg "VERSION=${VERSION}")
  cmd+=(--build-arg "PROJECT_NAME=${PROJECT_NAME}")

  # Add standard labels (injected at build time, no Dockerfile changes needed)
  local build_datetime
  build_datetime=$(date -u +%Y-%m-%dT%H:%M:%SZ)
  cmd+=(--label "version=${DOCKER_TAG}")
  cmd+=(--label "image.name=${TARGET_IMAGE_NAME}")
  cmd+=(--label "build.datetime=${build_datetime}")

  # Add squash if enabled
  if [[ "${SQUASH}" == "true" ]]; then
    cmd+=(--squash)
  fi

  # Disable layer caching by default for reproducible builds
  if [[ "${NO_CACHE}" == "true" ]]; then
    cmd+=(--no-cache)
  fi

  # Add context
  cmd+=("${context}")

  echo "" >&2
  echo "Building: ${cmd[*]}" >&2
  "${cmd[@]}"

  output_var "DOCKER_TARGET_IMAGE_FULL_URI" "${TARGET_IMAGE_FULL_URI}"

  echo "" >&2
  echo "Docker Build Dockerfile complete" >&2
}

main "$@"
