#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025-2026 Kaptain contributors (Fred Cooke)
#
# versions-and-naming - Router for version calculation and naming
#
# Delegates version calculation to a pluggable strategy and generates
# standardized outputs for CI pipelines.
#
# Outputs:
#   VERSION           - Numeric version (e.g., 1.2.3)
#   VERSION_MAJOR     - Major version number
#   VERSION_MINOR     - Minor version number
#   VERSION_PATCH     - Patch version number
#   VERSION_2_PART    - Version padded/truncated to 2 parts (e.g., 1.2)
#   VERSION_3_PART    - Version padded/truncated to 3 parts (e.g., 1.2.3)
#   VERSION_4_PART    - Version padded/truncated to 4 parts (e.g., 1.2.3.0)
#   DOCKER_TAG        - Same as VERSION on release branch, suffixed otherwise
#   DOCKER_IMAGE_NAME - Docker image name (prefix/project-name)
#   IS_RELEASE        - "true" if on release branch, "false" otherwise
#   PROJECT_NAME      - Repository name
#
set -euo pipefail

SCRIPT_DIR="$(dirname "${0}")"
PLUGINS_DIR="${SCRIPT_DIR}/../plugins"

# Logging configuration (CI-agnostic)
LOG_ERROR_PREFIX="${LOG_ERROR_PREFIX:-}"
LOG_ERROR_SUFFIX="${LOG_ERROR_SUFFIX:-}"

# Configuration with defaults
BUILD_MODE="${BUILD_MODE:-local}"
REPOSITORY_NAME="${REPOSITORY_NAME:?Is required}"
CURRENT_BRANCH="${CURRENT_BRANCH:?Is required}"
DEFAULT_BRANCH="${DEFAULT_BRANCH:-main}"
ADDITIONAL_RELEASE_BRANCHES="${ADDITIONAL_RELEASE_BRANCHES:-}"  # Comma-separated list of additional release branches
MAX_VERSION_PARTS="${MAX_VERSION_PARTS:-3}"  # Fail if version exceeds this many parts
TAG_VERSION_CALCULATION_STRATEGY="${TAG_VERSION_CALCULATION_STRATEGY:-git-auto-closest-highest}"
# For file-pattern-match strategy
TAG_VERSION_PATTERN_TYPE="${TAG_VERSION_PATTERN_TYPE:-dockerfile-env-kubectl}"
TAG_VERSION_PREFIX_PARTS="${TAG_VERSION_PREFIX_PARTS:-}"  # Number of parts from source version to use as prefix (default 2)
DOCKERFILE_SUB_PATH="${DOCKERFILE_SUB_PATH:-}"  # Fallback for dockerfile-env-kubectl pattern type
TAG_VERSION_SOURCE_SUB_PATH="${TAG_VERSION_SOURCE_SUB_PATH:-}"  # Optional override
TAG_VERSION_SOURCE_FILE_NAME="${TAG_VERSION_SOURCE_FILE_NAME:-}"  # Optional override
TAG_VERSION_SOURCE_CUSTOM_PATTERN="${TAG_VERSION_SOURCE_CUSTOM_PATTERN:-}"  # Required for custom type

if [[ "${BUILD_MODE}" != "local" && "${BUILD_MODE}" != "build_server" ]]; then
  echo "${LOG_ERROR_PREFIX}Invalid BUILD_MODE: ${BUILD_MODE}. Valid values: local, build_server${LOG_ERROR_SUFFIX}" >&2
  exit 1
fi

# Check if current branch is a release branch
is_release_branch() {
  local current_branch="${1}"

  # Check if it's the default branch
  if [[ "${current_branch}" == "${DEFAULT_BRANCH}" ]]; then
    return 0
  fi

  # Check if it matches any additional release branch
  if [[ -n "${ADDITIONAL_RELEASE_BRANCHES}" ]]; then
    IFS=',' read -ra branches <<< "${ADDITIONAL_RELEASE_BRANCHES}"
    for branch in "${branches[@]}"; do
      if [[ "${current_branch}" == "${branch}" ]]; then
        return 0
      fi
    done
  fi

  return 1
}

# Pad or truncate version to exactly N parts
version_to_n_parts() {
  local version="${1}"
  local n="${2}"
  version="${version#v}"

  IFS='.' read -ra parts <<< "${version}"
  local current_parts=${#parts[@]}

  # Build result with exactly n parts
  local result=""
  for ((i=0; i<n; i++)); do
    if [[ ${i} -gt 0 ]]; then
      result+="."
    fi
    if [[ ${i} -lt ${current_parts} ]]; then
      result+="${parts[${i}]}"
    else
      result+="0"
    fi
  done

  echo "${result}"
}

output_var() {
  local name="${1}"
  local value="${2}"

  echo "${name}=${value}"

  # If running in GitHub Actions, set output
  if [[ -n "${GITHUB_OUTPUT:-}" ]]; then
    echo "${name}=${value}" >> "${GITHUB_OUTPUT}"
  fi

  # Also export for downstream scripts
  export "${name}=${value}"
}

# Push tag to remote
push_tag() {
  local version="${1}"
  local project_name="${2}"
  git config user.email "noreply@kaptain.org"
  git config user.name "Kube Kaptain"
  git tag -m "Automatic release tag for version ${version} of ${project_name} by Kaptain build script." "${version}" HEAD
  git push origin "${version}"
}

main() {
  local current_branch="${CURRENT_BRANCH}"
  local project_name="${REPOSITORY_NAME}"

  # Determine if this is a release build
  # Local builds are never releases, regardless of branch
  local is_release="false"
  if [[ "${BUILD_MODE}" == "build_server" ]] && is_release_branch "${current_branch}"; then
    is_release="true"
  fi

  # Validate strategy plugin exists
  local strategy_script="${PLUGINS_DIR}/tag-version-calculation-providers/tag-version-calculation-${TAG_VERSION_CALCULATION_STRATEGY}"
  if [[ ! -x "${strategy_script}" ]]; then
    echo "${LOG_ERROR_PREFIX}Unknown tag version calculation strategy: ${TAG_VERSION_CALCULATION_STRATEGY}${LOG_ERROR_SUFFIX}" >&2
    echo "Expected executable: ${strategy_script}" >&2
    echo "Available strategies:" >&2
    for f in "${PLUGINS_DIR}"/tag-version-calculation-providers/tag-version-calculation-*; do
      if [[ -x "${f}" ]]; then
        local name
        name=$(basename "${f}")
        echo "  - ${name#tag-version-calculation-}" >&2
      fi
    done
    exit 1
  fi

  # Call the strategy plugin
  local plugin_output
  plugin_output=$(
    MAX_VERSION_PARTS="${MAX_VERSION_PARTS}" \
    TAG_VERSION_PATTERN_TYPE="${TAG_VERSION_PATTERN_TYPE}" \
    TAG_VERSION_PREFIX_PARTS="${TAG_VERSION_PREFIX_PARTS}" \
    DOCKERFILE_SUB_PATH="${DOCKERFILE_SUB_PATH}" \
    TAG_VERSION_SOURCE_SUB_PATH="${TAG_VERSION_SOURCE_SUB_PATH}" \
    TAG_VERSION_SOURCE_FILE_NAME="${TAG_VERSION_SOURCE_FILE_NAME}" \
    TAG_VERSION_SOURCE_CUSTOM_PATTERN="${TAG_VERSION_SOURCE_CUSTOM_PATTERN}" \
    LOG_ERROR_PREFIX="${LOG_ERROR_PREFIX}" \
    LOG_ERROR_SUFFIX="${LOG_ERROR_SUFFIX}" \
    "${strategy_script}"
  ) || exit $?

  # Parse VERSION from plugin output
  local version
  version=$(echo "${plugin_output}" | grep '^VERSION=' | cut -d= -f2-)

  if [[ -z "${version}" ]]; then
    echo "${LOG_ERROR_PREFIX}Strategy plugin did not output VERSION${LOG_ERROR_SUFFIX}" >&2
    exit 1
  fi

  # Push tag if this is a release build
  if [[ "${is_release}" == "true" ]]; then
    echo "Tagging release: ${version}" >&2
    push_tag "${version}" "${project_name}"
  else
    echo "Pre-release build: ${version} (no tag push)" >&2
  fi

  # Generate DOCKER_TAG based on release status
  local docker_tag
  if [[ "${is_release}" == "true" ]]; then
    docker_tag="${version}"
  else
    docker_tag="${version}-PRERELEASE"
  fi

  # Generate padded/truncated versions for different ecosystems
  local version_2_part version_3_part version_4_part
  version_2_part=$(version_to_n_parts "${version}" 2)
  version_3_part=$(version_to_n_parts "${version}" 3)
  version_4_part=$(version_to_n_parts "${version}" 4)

  # Extract individual parts (major.minor.patch...)
  local clean_version="${version#v}"
  IFS='.' read -ra version_parts <<< "${clean_version}"
  local version_major="${version_parts[0]:-0}"
  local version_minor="${version_parts[1]:-0}"
  local version_patch="${version_parts[2]:-0}"

  # Generate docker image name: prefix/full-name (e.g., my/my-project-sucks)
  local docker_image_name
  local prefix="${project_name%%-*}"
  docker_image_name="${prefix}/${project_name}"

  output_var "VERSION" "${version}"
  output_var "VERSION_MAJOR" "${version_major}"
  output_var "VERSION_MINOR" "${version_minor}"
  output_var "VERSION_PATCH" "${version_patch}"
  output_var "VERSION_2_PART" "${version_2_part}"
  output_var "VERSION_3_PART" "${version_3_part}"
  output_var "VERSION_4_PART" "${version_4_part}"
  output_var "DOCKER_TAG" "${docker_tag}"
  output_var "DOCKER_IMAGE_NAME" "${docker_image_name}"
  output_var "IS_RELEASE" "${is_release}"
  output_var "PROJECT_NAME" "${project_name}"
}

main "$@"
