#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025-2026 Kaptain contributors (Fred Cooke)
#
# basic-quality-checks - Enforces commit and branch quality standards
#
# Exit codes are bit flags (can be combined):
#   0  = All quality checks passed
#   1  = Conflicting configuration error or unexpected error from tooling
#   2  = Bad branch name. Checks:
#        - Auto-generated pattern: always-on (branch names in the form creator-patch-N)
#        - Slashes: default off (turn on with QC_BLOCK_SLASH_CONTAINING_BRANCHES=true)
#        - Double hyphens: default on (turn off with QC_BLOCK_DOUBLE_HYPHEN_CONTAINING_BRANCHES=false)
#        - Conventional prefixes: default off (turn on with QC_REQUIRE_CONVENTIONAL_BRANCHES=true)
#   4  = Bad commit message. Checks:
#        - Web UI auto-generated: always-on ("Update X", "Create X", "Delete X" are bad even if hand written)
#        - Require conventional format: default off (turn on with QC_REQUIRE_CONVENTIONAL_COMMITS=true)
#        - Block conventional format: default off (turn on with QC_BLOCK_CONVENTIONAL_COMMITS=true)
#   8  = Bad branch contents. Checks:
#        - Merge commit detected: always-on (no matter how they got there, eg back-merge from main)
#        - Not rebased onto target: always-on (must be up to date to guarantee correctness after merge)
#        - Duplicate commit messages: default on (turn off with QC_BLOCK_DUPLICATE_COMMIT_MESSAGES=false)
#   16 = Bad merge candidate setup. Checks:
#        - Invalid target branch: always-on (controlled by RELEASE_BRANCH and ADDITIONAL_RELEASE_BRANCHES)
#        - Target branch not found: always-on
#   32 = Reserved
#   64 = Reserved
#  128 = Reserved
#
set -uo pipefail

SCRIPT_DIR="$(dirname "${0}")"

# Script-specific inputs
TARGET_BRANCH="${TARGET_BRANCH:?Is required - quality checks only make sense in PR context}"
MERGE_CANDIDATE_CREATOR="${MERGE_CANDIDATE_CREATOR:-}"

# shellcheck source=src/scripts/defaults/quality-checks.bash
source "${SCRIPT_DIR}/../defaults/quality-checks.bash"
# shellcheck source=src/scripts/defaults/platform.bash
source "${SCRIPT_DIR}/../defaults/platform.bash"

CONVENTIONAL_BRANCH_PREFIXES="feature/|feat/|bugfix/|fix/|hotfix/|release/|chore/"
CONVENTIONAL_COMMIT_TYPES="build:|chore:|ci:|docs:|feat:|fix:|perf:|refactor:|revert:|style:|test:"

# Bit flags for exit codes (1 reserved for config/unexpected errors)
FLAG_BAD_BRANCH=2
FLAG_BAD_COMMIT=4
FLAG_BAD_CONTENTS=8
FLAG_BAD_SETUP=16

# shellcheck source=src/scripts/defaults/branch-inputs.bash
source "${SCRIPT_DIR}/../defaults/branch-inputs.bash"

# shellcheck source=src/scripts/lib/branch-setup-shared.bash
source "${SCRIPT_DIR}/../lib/branch-setup-shared.bash"
# shellcheck source=src/scripts/lib/log.bash
source "${SCRIPT_DIR}/../lib/log.bash"

# Accumulated error code
ERROR_CODE=0

# Check for GitHub default branch naming pattern
is_github_default_branch_name() {
  local branch="$1"

  # Only check if we know the PR creator
  if [[ -z "${MERGE_CANDIDATE_CREATOR}" ]]; then
    return 1
  fi

  # Pattern: <pr-creator>-patch-<number>
  if [[ "${CURRENT_BRANCH}" == "${MERGE_CANDIDATE_CREATOR}-patch-"* ]] && [[ "${CURRENT_BRANCH}" =~ -patch-[0-9]+$ ]]; then
    return 0
  fi

  return 1
}

# Check if branch contains a slash
has_slash() {
  local branch="$1"
  [[ "${CURRENT_BRANCH}" == *"/"* ]]
}

# Check if branch contains double hyphens
has_double_hyphen() {
  local branch="$1"
  [[ "${CURRENT_BRANCH}" == *"--"* ]]
}

# Check if branch starts with an allowed prefix
has_branch_prefix() {
  local branch="$1"
  echo "${CURRENT_BRANCH}" | grep -qE "^(${CONVENTIONAL_BRANCH_PREFIXES})"
}

# Check if commit message starts with a conventional type
is_conventional_commit() {
  local commit="$1"
  local message
  message=$(git log -1 --format="%s" "${commit}")
  echo "${message}" | grep -qE "^(${CONVENTIONAL_COMMIT_TYPES})"
}

# Resolve target branch to the correct ref (origin/$target in CI, $target locally)
resolve_target_ref() {
  local target="$1"

  if git remote | grep -q origin; then
    if git fetch origin "${target}" --quiet 2>/dev/null; then
      echo "origin/${target}"
    elif git rev-parse "${target}" &>/dev/null; then
      echo "${target}"
    else
      log_error "Target branch '${target}' not found on origin or locally"
      exit 42
    fi
  else
    echo "${target}"
  fi
}

# Get commits unique to this branch (not in target)
get_branch_commits() {
  local target="$1"
  local target_ref
  target_ref=$(resolve_target_ref "${target}")
  git log --format="%H" "${target_ref}..HEAD" 2>/dev/null
}

# Check if a commit is a merge commit
is_merge_commit() {
  local commit="$1"
  local parent_count
  parent_count=$(git rev-list --parents -n1 "${commit}" | wc -w)
  [[ ${parent_count} -gt 2 ]]
}

# Check if commit message matches GitHub UI default pattern
# Matches "Update <filename>..." or "Create <filename>..." or "Delete <filename>..."
# where <filename> is the actual single file changed in that commit
is_github_ui_commit() {
  local commit="$1"
  local message
  message=$(git log -1 --format="%s" "${commit}")

  # Get first two words
  local first_word second_word
  first_word=$(echo "${message}" | awk '{print $1}')
  second_word=$(echo "${message}" | awk '{print $2}')

  # Check if first word is Update/Create/Delete
  if [[ "${first_word}" != "Update" && "${first_word}" != "Create" && "${first_word}" != "Delete" ]]; then
    return 1
  fi

  # Get the single file changed in this commit
  local files_changed
  files_changed=$(git diff-tree --no-commit-id --name-only -r "${commit}")
  local file_count
  file_count=$(echo "${files_changed}" | wc -l | tr -d ' ')

  # Only flag if single file changed and it matches the second word
  if [[ "${file_count}" -eq 1 ]]; then
    local changed_file
    changed_file=$(echo "${files_changed}" | head -1)
    # Check if second word matches the filename (with or without path)
    local basename_changed
    basename_changed=$(basename "${changed_file}")
    if [[ "${second_word}" == "${changed_file}" || "${second_word}" == "${basename_changed}" ]]; then
      return 0
    fi
  fi

  return 1
}

# Check if branch is a fast-forward from target
is_ff_from_target() {
  local target="$1"
  local target_ref
  target_ref=$(resolve_target_ref "${target}")

  if ! git rev-parse "${target_ref}" &>/dev/null; then
    log_error "Target ref '${target_ref}' not found"
    exit 42
  fi

  git merge-base --is-ancestor "${target_ref}" HEAD
}

# Report error (accumulates, doesn't exit)
error() {
  local flag="$1"
  local message="$2"
  log_error "${message}"
  log "✗ ${message}"
  ERROR_CODE=$((ERROR_CODE | flag))
}

# Report success
pass() {
  local message="$1"
  log "✓ ${message}"
}

main() {
  log "Checking quality for branch: ${CURRENT_BRANCH}"
  log "Target branch: ${TARGET_BRANCH}"

  # Check: Block release branch to release branch PRs
  if is_release_branch "${CURRENT_BRANCH}" && is_release_branch "${TARGET_BRANCH}"; then
    error ${FLAG_BAD_SETUP} "PR from release branch '${CURRENT_BRANCH}' to release branch '${TARGET_BRANCH}' is not valid. Use cherry-pick to move changes between release branches."
    exit ${FLAG_BAD_SETUP} # Since we're first just ignore the value out of the error function and keep this clear
  fi

  # Fail for release branches - shouldn't be running in this context
  if is_release_branch "${CURRENT_BRANCH}"; then
    log_error "Quality checks should not run on release branches. Check workflow configuration."
    exit 1
  fi

  # Check 1: Block GitHub default branch names
  if is_github_default_branch_name "${CURRENT_BRANCH}"; then
    error ${FLAG_BAD_BRANCH} "Branch name '${CURRENT_BRANCH}' matches GitHub's default naming pattern. Please use a descriptive branch name."
  else
    pass "Branch name is not a GitHub default"
  fi

  # Check 2: Optionally block slashes in branch names
  if [[ "${QC_BLOCK_SLASH_CONTAINING_BRANCHES}" == "true" ]]; then
    if has_slash "${CURRENT_BRANCH}"; then
      error ${FLAG_BAD_BRANCH} "Branch name '${CURRENT_BRANCH}' contains a slash. Please use hyphens instead."
    else
      pass "Branch name contains no slashes"
    fi
  fi

  # Check 3: Block double hyphens in branch names (default: on)
  if [[ "${QC_BLOCK_DOUBLE_HYPHEN_CONTAINING_BRANCHES}" == "true" ]]; then
    if has_double_hyphen "${CURRENT_BRANCH}"; then
      error ${FLAG_BAD_BRANCH} "Branch name '${CURRENT_BRANCH}' contains double hyphens. This is likely a typo."
    else
      pass "Branch name contains no double hyphens"
    fi
  fi

  # Check 4: Optionally require branch prefix (feature/, fix/, etc.)
  if [[ "${QC_REQUIRE_CONVENTIONAL_BRANCHES}" == "true" ]]; then
    if has_branch_prefix "${CURRENT_BRANCH}"; then
      pass "Branch name has required prefix"
    else
      error ${FLAG_BAD_BRANCH} "Branch name '${CURRENT_BRANCH}' must start with a prefix: feature/, feat/, bugfix/, fix/, hotfix/, release/, or chore/"
    fi
  fi

  # Check 5: Validate PR target branch
  if ! is_release_branch "${TARGET_BRANCH}"; then
    error ${FLAG_BAD_SETUP} "PR targets '${TARGET_BRANCH}' which is not a release branch. PRs must target ${RELEASE_BRANCH} or a configured additional release branch."
  else
    pass "PR targets an allowed branch"
  fi

  # Get commits to check
  local commits
  commits=$(get_branch_commits "${TARGET_BRANCH}")

  if [[ -z "${commits}" ]]; then
    log "No commits to check (branch may already be merged)"
  else
    local commit_count
    commit_count=$(echo "${commits}" | wc -l | tr -d ' ')

    # Check 6: No merge commits
    local merge_found=false
    for commit in ${commits}; do
      if is_merge_commit "${commit}"; then
        error ${FLAG_BAD_CONTENTS} "Commit ${commit} is a merge commit. Please rebase your branch instead of merging."
        merge_found=true
      fi
    done
    if [[ "${merge_found}" == "false" ]]; then
      pass "No merge commits found from ${commit_count} commits checked"
    fi

    # Check 7: No GitHub UI default commit messages
    local bad_msg_found=false
    for commit in ${commits}; do
      if is_github_ui_commit "${commit}"; then
        local msg
        msg=$(git log -1 --format="%s" "${commit}")
        error ${FLAG_BAD_COMMIT} "Commit ${commit} appears to have a GitHub UI default message: '${msg}'. Please use descriptive commit messages. All commits update something - never include Update in your message."
        bad_msg_found=true
      fi
    done
    if [[ "${bad_msg_found}" == "false" ]]; then
      pass "No GitHub generated commit messages from ${commit_count} commits checked"
    fi

    # Check 8: Optionally require conventional commit format
    if [[ "${QC_REQUIRE_CONVENTIONAL_COMMITS}" == "true" ]]; then
      local non_conventional_found=false
      for commit in ${commits}; do
        if ! is_conventional_commit "${commit}"; then
          local msg
          msg=$(git log -1 --format="%s" "${commit}")
          error ${FLAG_BAD_COMMIT} "Commit ${commit} does not use conventional commit format: '${msg}'. Must start with: build:, chore:, ci:, docs:, feat:, fix:, perf:, refactor:, revert:, style:, or test:"
          non_conventional_found=true
        fi
      done
      if [[ "${non_conventional_found}" == "false" ]]; then
        pass "All commits use conventional commit format"
      fi
    fi

    # Check 9: Optionally block conventional commit format
    if [[ "${QC_BLOCK_CONVENTIONAL_COMMITS}" == "true" ]]; then
      local conventional_found=false
      for commit in ${commits}; do
        if is_conventional_commit "${commit}"; then
          local msg
          msg=$(git log -1 --format="%s" "${commit}")
          error ${FLAG_BAD_COMMIT} "Commit ${commit} uses conventional commit format which is not allowed: '${msg}'"
          conventional_found=true
        fi
      done
      if [[ "${conventional_found}" == "false" ]]; then
        pass "No commits use conventional commit format"
      fi
    fi

    # Check 10: Block duplicate commit messages (default: on)
    if [[ "${QC_BLOCK_DUPLICATE_COMMIT_MESSAGES}" == "true" ]]; then
      local messages=()
      for commit in ${commits}; do
        messages+=("$(git log -1 --format="%s" "${commit}")")
      done
      local duplicates_found=false
      local seen=()
      for msg in "${messages[@]}"; do
        local count=0
        for other in "${messages[@]}"; do
          if [[ "${msg}" == "${other}" ]]; then
            count=$((count + 1))
          fi
        done
        if [[ ${count} -gt 1 ]]; then
          # Only report each duplicate message once
          local already_reported=false
          for s in "${seen[@]+"${seen[@]}"}"; do
            if [[ "${s}" == "${msg}" ]]; then
              already_reported=true
              break
            fi
          done
          if [[ "${already_reported}" == "false" ]]; then
            error ${FLAG_BAD_CONTENTS} "Duplicate commit message found ${count} times: '${msg}'"
            seen+=("${msg}")
            duplicates_found=true
          fi
        fi
      done
      if [[ "${duplicates_found}" == "false" ]]; then
        pass "No duplicate commit messages from ${commit_count} commits checked"
      fi
    fi
  fi

  # Check 11: Branch is fast-forward from target
  if ! is_ff_from_target "${TARGET_BRANCH}"; then
    error ${FLAG_BAD_CONTENTS} "Branch is not up to date with '${TARGET_BRANCH}'. Please rebase your branch."
  else
    pass "Branch is fast-forward from target"
  fi

  if [[ ${ERROR_CODE} -eq 0 ]]; then
    log "All quality checks passed!"
  fi

  exit ${ERROR_CODE}
}

main "$@"
