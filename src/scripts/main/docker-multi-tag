#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025-2026 Kaptain contributors (Fred Cooke)
#
# docker-multi-tag - Discovers and tags all matching images for additional registries
#
# Discovers all local images matching the primary registry/image-name/tag pattern
# and retags each one for every configured push target. This handles all image
# types (main build, manifests, release-change-data, etc.) automatically.
#
# Inputs (environment variables):
#   DOCKER_IMAGE_NAME        - Image name portion (required)
#   DOCKER_TAG               - Base tag for images (required)
#   DOCKER_PUSH_TARGETS      - JSON array of targets [{registry, namespace?}] (required)
#   DOCKER_TARGET_REGISTRY   - Primary registry to filter source images (required)
#   DOCKER_TARGET_NAMESPACE   - Primary namespace (optional, from defaults)
#   DOCKER_PUSH_IMAGE_LIST_FILE - Path to image URIs file (required, from docker-registry-logins)
#   IMAGE_BUILD_COMMAND      - Container runtime command (default: docker)
#
# Each target in the JSON array:
#   registry  - Target registry (required)
#   namespace - Optional namespace within registry
#
# Outputs:
#   IMAGES_TAGGED - Number of images tagged
#
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# shellcheck source=src/scripts/defaults/platform.bash
source "${SCRIPT_DIR}/../defaults/platform.bash"
# shellcheck source=src/scripts/defaults/docker-push-image-list.bash
source "${SCRIPT_DIR}/../defaults/docker-push-image-list.bash"
# shellcheck source=src/scripts/defaults/docker-build.bash
source "${SCRIPT_DIR}/../defaults/docker-build.bash"
# shellcheck source=src/scripts/defaults/docker-common.bash
source "${SCRIPT_DIR}/../defaults/docker-common.bash"
# shellcheck source=src/scripts/defaults/output-sub-path.bash
source "${SCRIPT_DIR}/../defaults/output-sub-path.bash"
# shellcheck source=src/scripts/lib/output-var.bash
source "${SCRIPT_DIR}/../lib/output-var.bash"
# shellcheck source=src/scripts/lib/log.bash
source "${SCRIPT_DIR}/../lib/log.bash"

# Validate required inputs
if [[ -z "${DOCKER_IMAGE_NAME:-}" ]]; then
  log_error "DOCKER_IMAGE_NAME is required"
  exit 1
fi
if [[ -z "${DOCKER_TAG:-}" ]]; then
  log_error "DOCKER_TAG is required"
  exit 1
fi
if [[ -z "${DOCKER_PUSH_TARGETS}" ]]; then
  log_error "DOCKER_PUSH_TARGETS is required"
  exit 1
fi
if [[ -z "${DOCKER_TARGET_REGISTRY:-}" ]]; then
  log_error "DOCKER_TARGET_REGISTRY is required"
  exit 1
fi

# Build full image URI from components
build_image_uri() {
  local registry="${1}"
  local namespace="${2}"
  local image_name="${3}"
  local tag="${4}"

  if [[ -n "${namespace}" ]]; then
    echo "${registry}/${namespace}/${image_name}:${tag}"
  else
    echo "${registry}/${image_name}:${tag}"
  fi
}

main() {
  log "=== Docker Multi-Tag ==="
  log "Image name: ${DOCKER_IMAGE_NAME}"
  log "Base tag: ${DOCKER_TAG}"
  log "Source registry: ${DOCKER_TARGET_REGISTRY}"
  log "Source namespace: ${DOCKER_TARGET_NAMESPACE:-<none>}"
  log "========================"

  # Validate JSON before processing
  if ! echo "${DOCKER_PUSH_TARGETS}" | jq -e 'type == "array"' > /dev/null 2>&1; then
    log_error "DOCKER_PUSH_TARGETS must be a valid JSON array"
    exit 1
  fi

  # Build source reference filter
  local source_prefix
  source_prefix=$(build_image_uri "${DOCKER_TARGET_REGISTRY}" "${DOCKER_TARGET_NAMESPACE:-}" "${DOCKER_IMAGE_NAME}" "")
  # Remove trailing colon for the filter prefix
  source_prefix="${source_prefix%:}"

  local filter_reference="${source_prefix}:${DOCKER_TAG}*"
  log "Filter: ${filter_reference}"

  # Discover all matching tags
  local tags
  tags=$(${IMAGE_BUILD_COMMAND} images --filter "reference=${filter_reference}" --format '{{.Tag}}' 2>/dev/null || true)

  if [[ -z "${tags}" ]]; then
    log "No images found matching filter - nothing to tag"
    output_var "IMAGES_TAGGED" "0"
    return 0
  fi

  log "Discovered tags:"
  echo "${tags}" | while IFS= read -r tag; do
    log "  ${tag}"
  done

  local count=0

  # For each discovered tag, retag for each push target
  while IFS= read -r tag; do
    [[ -z "${tag}" ]] && continue

    local source_uri="${source_prefix}:${tag}"

    while IFS= read -r target; do
      local registry namespace target_uri

      registry=$(echo "${target}" | jq -r '.registry')
      namespace=$(echo "${target}" | jq -r '.["namespace"] // ""')

      # Validate registry is present
      if [[ -z "${registry}" ]] || [[ "${registry}" == "null" ]]; then
        log_error "Push target missing required 'registry' field"
        exit 1
      fi

      target_uri=$(build_image_uri "${registry}" "${namespace}" "${DOCKER_IMAGE_NAME}" "${tag}")

      log "Tagging: ${source_uri} -> ${target_uri}"
      ${IMAGE_BUILD_COMMAND} tag "${source_uri}" "${target_uri}"

      # Register image for consolidated push
      echo "${target_uri}" >> "${DOCKER_PUSH_IMAGE_LIST_FILE}"

      count=$((count + 1))
    done < <(echo "${DOCKER_PUSH_TARGETS}" | jq -c '.[]')
  done <<< "${tags}"

  # === Manifest list handling for multi-platform ===
  # When multi-platform is active, register base URIs (without arch suffix)
  # in manifest-uris for each target registry. This ensures docker-push-all
  # creates manifest lists for additional registries too.
  if [[ "${DOCKER_PLATFORM}" == *,* ]]; then
    local manifest_uris_file="${OUTPUT_SUB_PATH}/docker-push-all/manifest-uris"
    mkdir -p "$(dirname "${manifest_uris_file}")"

    log ""
    log "Multi-platform active - registering manifest URIs for additional registries..."

    while IFS= read -r target; do
      local registry namespace manifest_uri

      registry=$(echo "${target}" | jq -r '.registry')
      namespace=$(echo "${target}" | jq -r '.["namespace"] // ""')
      manifest_uri=$(build_image_uri "${registry}" "${namespace}" "${DOCKER_IMAGE_NAME}" "${DOCKER_TAG}")

      log "  ${manifest_uri}"
      echo "${manifest_uri}" >> "${manifest_uris_file}"
    done < <(echo "${DOCKER_PUSH_TARGETS}" | jq -c '.[]')
  fi

  output_var "IMAGES_TAGGED" "${count}"

  log ""
  log "Docker Multi-Tag complete: ${count} image(s) tagged"
}

main "$@"
