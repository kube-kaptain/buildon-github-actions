#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025-2026 Kaptain contributors (Fred Cooke)
#
# docker-multi-tag - Discovers and tags all matching images for additional registries
#
# Discovers all local images matching the primary registry/image-name/tag pattern
# and retags each one for every configured push target. This handles all image
# types (main build, manifests, release-change-data, etc.) automatically.
#
# Inputs (environment variables):
#   DOCKER_IMAGE_NAME        - Image name portion (required)
#   DOCKER_TAG               - Base tag for images (required)
#   DOCKER_PUSH_TARGETS      - JSON array of targets [{registry, base-path?}] (required)
#   DOCKER_TARGET_REGISTRY   - Primary registry to filter source images (required)
#   DOCKER_TARGET_BASE_PATH  - Primary base path (optional, from defaults)
#   DOCKER_PUSH_IMAGE_LIST_FILE - Path to image URIs file (required, from docker-registry-logins)
#   IMAGE_BUILD_COMMAND      - Container runtime command (default: docker)
#
# Each target in the JSON array:
#   registry  - Target registry (required)
#   base-path - Optional base path within registry
#
# Outputs:
#   IMAGES_TAGGED - Number of images tagged
#
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# shellcheck source=src/scripts/defaults/docker-push-image-list.bash
source "${SCRIPT_DIR}/../defaults/docker-push-image-list.bash"
# shellcheck source=src/scripts/defaults/docker-build.bash
source "${SCRIPT_DIR}/../defaults/docker-build.bash"
# shellcheck source=src/scripts/defaults/image-build-command.bash
source "${SCRIPT_DIR}/../defaults/image-build-command.bash"

# Validate required inputs
if [[ -z "${DOCKER_IMAGE_NAME:-}" ]]; then
  echo "DOCKER_IMAGE_NAME is required" >&2
  exit 1
fi
if [[ -z "${DOCKER_TAG:-}" ]]; then
  echo "DOCKER_TAG is required" >&2
  exit 1
fi
if [[ -z "${DOCKER_PUSH_TARGETS}" ]]; then
  echo "DOCKER_PUSH_TARGETS is required" >&2
  exit 1
fi
if [[ -z "${DOCKER_TARGET_REGISTRY:-}" ]]; then
  echo "DOCKER_TARGET_REGISTRY is required" >&2
  exit 1
fi

# Output variable for GitHub Actions
output_var() {
  local name="${1}"
  local value="${2}"

  echo "${name}=${value}"

  if [[ -n "${GITHUB_OUTPUT:-}" ]]; then
    echo "${name}=${value}" >> "${GITHUB_OUTPUT}"
  fi
}

# Build full image URI from components
build_image_uri() {
  local registry="${1}"
  local base_path="${2}"
  local image_name="${3}"
  local tag="${4}"

  if [[ -n "${base_path}" ]]; then
    echo "${registry}/${base_path}/${image_name}:${tag}"
  else
    echo "${registry}/${image_name}:${tag}"
  fi
}

main() {
  echo "=== Docker Multi-Tag ===" >&2
  echo "Image name: ${DOCKER_IMAGE_NAME}" >&2
  echo "Base tag: ${DOCKER_TAG}" >&2
  echo "Source registry: ${DOCKER_TARGET_REGISTRY}" >&2
  echo "Source base path: ${DOCKER_TARGET_BASE_PATH:-<none>}" >&2
  echo "========================" >&2

  # Validate JSON before processing
  if ! echo "${DOCKER_PUSH_TARGETS}" | jq -e 'type == "array"' > /dev/null 2>&1; then
    echo "${LOG_ERROR_PREFIX:-}DOCKER_PUSH_TARGETS must be a valid JSON array${LOG_ERROR_SUFFIX:-}" >&2
    exit 1
  fi

  # Build source reference filter
  local source_prefix
  source_prefix=$(build_image_uri "${DOCKER_TARGET_REGISTRY}" "${DOCKER_TARGET_BASE_PATH:-}" "${DOCKER_IMAGE_NAME}" "")
  # Remove trailing colon for the filter prefix
  source_prefix="${source_prefix%:}"

  local filter_reference="${source_prefix}:${DOCKER_TAG}*"
  echo "Filter: ${filter_reference}" >&2

  # Discover all matching tags
  local tags
  tags=$(${IMAGE_BUILD_COMMAND} images --filter "reference=${filter_reference}" --format '{{.Tag}}' 2>/dev/null || true)

  if [[ -z "${tags}" ]]; then
    echo "No images found matching filter - nothing to tag" >&2
    output_var "IMAGES_TAGGED" "0"
    return 0
  fi

  echo "Discovered tags:" >&2
  echo "${tags}" | while IFS= read -r tag; do
    echo "  ${tag}" >&2
  done

  local count=0

  # For each discovered tag, retag for each push target
  while IFS= read -r tag; do
    [[ -z "${tag}" ]] && continue

    local source_uri="${source_prefix}:${tag}"

    while IFS= read -r target; do
      local registry base_path target_uri

      registry=$(echo "${target}" | jq -r '.registry')
      base_path=$(echo "${target}" | jq -r '.["base-path"] // ""')

      # Validate registry is present
      if [[ -z "${registry}" ]] || [[ "${registry}" == "null" ]]; then
        echo "${LOG_ERROR_PREFIX:-}Push target missing required 'registry' field${LOG_ERROR_SUFFIX:-}" >&2
        exit 1
      fi

      target_uri=$(build_image_uri "${registry}" "${base_path}" "${DOCKER_IMAGE_NAME}" "${tag}")

      echo "Tagging: ${source_uri} -> ${target_uri}" >&2
      ${IMAGE_BUILD_COMMAND} tag "${source_uri}" "${target_uri}"

      # Register image for consolidated push
      echo "${target_uri}" >> "${DOCKER_PUSH_IMAGE_LIST_FILE}"

      count=$((count + 1))
    done < <(echo "${DOCKER_PUSH_TARGETS}" | jq -c '.[]')
  done <<< "${tags}"

  output_var "IMAGES_TAGGED" "${count}"

  echo "" >&2
  echo "Docker Multi-Tag complete: ${count} image(s) tagged" >&2
}

main "$@"
