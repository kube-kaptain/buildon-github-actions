#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025-2026 Kaptain contributors (Fred Cooke)
#
# docker-registry-logins - Router for multi-registry authentication
#
# Reads login configuration from CONFIG env var (inline YAML) and routes
# to the appropriate login script for each configured registry.
#
# Registry URL is the key - prevents duplicates and makes config explicit:
#   docker.io:
#     type: username-password
#     username-secret: DOCKERHUB_USER
#     password-secret: DOCKERHUB_PASS
#
# Inputs (environment variables):
#   CONFIG - YAML config with registry logins (registry URL as key) - required
#   SECRET_METHOD - Secret retrieval method (github, env) - required
#   SECRETS_JSON - JSON object containing secret values keyed by secret name
#   OUTPUT_SUB_PATH - Build output directory (default: target)
#
# Outputs:
#   DOCKER_PUSH_IMAGE_LIST_FILE - Path to file listing image URIs for docker-push-all
#
set -euo pipefail

SCRIPT_DIR="$(dirname "${0}")"
PLUGINS_DIR="${SCRIPT_DIR}/../plugins"

# shellcheck source=src/scripts/defaults/output-sub-path.bash
source "${SCRIPT_DIR}/../defaults/output-sub-path.bash"
# shellcheck source=src/scripts/defaults/platform.bash
source "${SCRIPT_DIR}/../defaults/platform.bash"

# shellcheck source=src/scripts/lib/output-var.bash
source "${SCRIPT_DIR}/../lib/output-var.bash"
# shellcheck source=src/scripts/lib/log.bash
source "${SCRIPT_DIR}/../lib/log.bash"

# Config from inline YAML - required
if [[ -z "${CONFIG:-}" ]]; then
  log_error "CONFIG is required"
  exit 1
fi

# Secret retrieval method - required
if [[ -z "${SECRET_METHOD:-}" ]]; then
  log_error "SECRET_METHOD is required (github, env)"
  exit 1
fi

# Secrets passed as JSON (exported for get-secret-github)
export SECRETS_JSON="${SECRETS_JSON:-{\}}"

# Validate secret method exists
validate_secret_method() {
  local method="${1}"
  local script="${PLUGINS_DIR}/secret-value-providers/get-secret-${method}"
  if [[ ! -x "${script}" ]]; then
    log_error "Unknown secret method: ${method} (no executable ${script})"
    log "Available methods:"
    for f in "${PLUGINS_DIR}"/secret-value-providers/get-secret-*; do
      [[ -x "${f}" ]] && log "  - ${f##*get-secret-}"
    done
    return 1
  fi
}

# Helper to extract config value with yq
cfg() {
  local registry="${1}" key="${2}"
  echo "${CONFIG}" | yq -r ".[\"${registry}\"][\"${key}\"]"
}

# Get required secret names for a registry based on its type
get_required_secrets() {
  local registry="${1}"
  local login_type
  login_type=$(echo "${CONFIG}" | yq -r ".[\"${registry}\"].type")

  case "${login_type}" in
    username-password)
      cfg "${registry}" "username-secret"
      cfg "${registry}" "password-secret"
      ;;
    aws-ecr)
      cfg "${registry}" "access-key-id-secret"
      cfg "${registry}" "secret-access-key-secret"
      ;;
    gcp-gar)
      cfg "${registry}" "service-account-key-secret"
      ;;
    azure-acr)
      cfg "${registry}" "client-id-secret"
      cfg "${registry}" "client-secret-secret"
      cfg "${registry}" "tenant-id-secret"
      ;;
    # Types that don't use secrets from the secret store
    github-token|aws-ecr-github-actions-oidc|gcp-gar-github-actions-oidc|azure-acr-github-actions-oidc)
      ;;
  esac
}

# Validate all secrets exist before attempting any logins
validate_all_secrets() {
  local get_secret="${PLUGINS_DIR}/secret-value-providers/get-secret-${SECRET_METHOD}"
  local found_secrets=()
  local missing_secrets=()
  local registries

  registries=$(echo "${CONFIG}" | yq -r 'keys | .[]')
  [[ -z "${registries}" ]] && return 0

  # Collect all required secrets and check each one
  while IFS= read -r registry; do
    local secrets
    secrets=$(get_required_secrets "${registry}")
    [[ -z "${secrets}" ]] && continue

    while IFS= read -r secret_name; do
      [[ -z "${secret_name}" ]] && continue
      if "${get_secret}" "${secret_name}" > /dev/null 2>&1; then
        found_secrets+=("${secret_name} (${registry})")
      else
        missing_secrets+=("${secret_name} (${registry})")
      fi
    done <<< "${secrets}"
  done <<< "${registries}"

  # Report results
  log "Analysis found ${#found_secrets[@]} secrets with ${#missing_secrets[@]} missing secrets."
  log ""
  log "Missing secrets:"
  for s in ${missing_secrets[@]+"${missing_secrets[@]}"}; do
    log "  - ${s}"
  done
  log ""
  log "Available secrets:"
  for s in ${found_secrets[@]+"${found_secrets[@]}"}; do
    log "  - ${s}"
  done
  log ""

  # Bail if anything we wanted isn't there.
  if [[ ${#missing_secrets[@]} -gt 0 ]]; then
    log_error "Secret validation failed"
    return 1
  fi
  return 0
}

# Route to the appropriate login script
route_login() {
  local registry="${1}"
  local login_type
  login_type=$(echo "${CONFIG}" | yq -r ".[\"${registry}\"].type")

  local login_script="${PLUGINS_DIR}/docker-login-providers/docker-login-${login_type}"
  if [[ ! -x "${login_script}" ]]; then
    log_error "Unknown login type: ${login_type} (no executable ${login_script})"
    return 1
  fi

  log "Login: ${registry} (${login_type})"

  case "${login_type}" in
    username-password)
      "${login_script}" "${SECRET_METHOD}" "${registry}" \
        "$(cfg "${registry}" "username-secret")" \
        "$(cfg "${registry}" "password-secret")"
      ;;

    github-token)
      "${login_script}" "${SECRET_METHOD}" "${registry}" \
        "$(cfg "${registry}" "token")" \
        "$(cfg "${registry}" "actor")"
      ;;

    aws-ecr)
      "${login_script}" "${SECRET_METHOD}" "${registry}" \
        "$(cfg "${registry}" "region")" \
        "$(cfg "${registry}" "access-key-id-secret")" \
        "$(cfg "${registry}" "secret-access-key-secret")"
      ;;

    aws-ecr-github-actions-oidc)
      local session_name
      session_name=$(echo "${CONFIG}" | yq -r ".[\"${registry}\"][\"session-name\"] // \"github-actions\"")
      "${login_script}" "${SECRET_METHOD}" "${registry}" \
        "$(cfg "${registry}" "role-arn")" \
        "$(cfg "${registry}" "region")" \
        "${session_name}"
      ;;

    gcp-gar)
      "${login_script}" "${SECRET_METHOD}" "${registry}" \
        "$(cfg "${registry}" "service-account-key-secret")"
      ;;

    gcp-gar-github-actions-oidc)
      "${login_script}" "${SECRET_METHOD}" "${registry}" \
        "$(cfg "${registry}" "workload-identity-provider")" \
        "$(cfg "${registry}" "service-account")"
      ;;

    azure-acr)
      "${login_script}" "${SECRET_METHOD}" "${registry}" \
        "$(cfg "${registry}" "client-id-secret")" \
        "$(cfg "${registry}" "client-secret-secret")" \
        "$(cfg "${registry}" "tenant-id-secret")"
      ;;

    azure-acr-github-actions-oidc)
      "${login_script}" "${SECRET_METHOD}" "${registry}" \
        "$(cfg "${registry}" "client-id")" \
        "$(cfg "${registry}" "tenant-id")" \
        "$(cfg "${registry}" "subscription-id")"
      ;;

    *)
      # Should not reach here due to executable check above
      log_error "Unknown login type: ${login_type}"
      return 1
      ;;
  esac

  log "Successfully authenticated to ${registry}"
}

main() {
  log "=== Docker Logins ==="

  # Validate secret method first
  validate_secret_method "${SECRET_METHOD}" || exit 1
  log "Secret provider: get-secret-${SECRET_METHOD}"

  # Report available secrets (names only, never values)
  local secret_keys
  secret_keys=$(echo "${SECRETS_JSON}" | yq -r 'keys | .[]' 2>/dev/null || true)
  if [[ -z "${secret_keys}" ]]; then
    log "SECRETS_JSON contains 0 keys (empty or invalid JSON)"
    log "Raw SECRETS_JSON value:"
    log "${SECRETS_JSON}"
  else
    local key_count
    key_count=$(echo "${secret_keys}" | wc -l | tr -d ' ')
    log "SECRETS_JSON contains ${key_count} keys:"
    while IFS= read -r key; do
      log "  - ${key}"
    done <<< "${secret_keys}"
  fi

  # Validate all secrets exist before attempting any logins
  validate_all_secrets || exit 1

  # Get list of registries
  local registries
  registries=$(echo "${CONFIG}" | yq -r 'keys | .[]')

  if [[ -z "${registries}" ]]; then
    log "No registries configured"
    exit 0
  fi

  # Process each registry
  local count=0
  while IFS= read -r registry; do
    route_login "${registry}"
    count=$((count + 1))
  done <<< "${registries}"

  log "Docker Logins complete - authenticated to ${count} registry/registries"

  # Set up the push image list file for all downstream build/tag steps
  DOCKER_PUSH_IMAGE_LIST_FILE="${OUTPUT_SUB_PATH}/docker-push-all/image-uris"
  mkdir -p "$(dirname "${DOCKER_PUSH_IMAGE_LIST_FILE}")"
  output_var "DOCKER_PUSH_IMAGE_LIST_FILE" "${DOCKER_PUSH_IMAGE_LIST_FILE}"
}

main "$@"
