#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025 Kaptain contributors (Fred Cooke)
#
# kubernetes-manifest-package - Packages Kubernetes manifests into a zip with variable substitution
#
# Inputs (environment variables):
#   MANIFESTS_SUB_PATH  - Source directory, relative (default: src/kubernetes)
#   PROJECT_NAME    - For variable substitution (required)
#   VERSION         - For variable substitution (required)
#   OUTPUT_SUB_PATH - Build output directory, relative (default: target)
#   DOCKER_TAG      - Docker tag for substitution (optional)
#   DOCKER_IMAGE_NAME - Docker image name for substitution (optional)
#   DOCKER_IMAGE_FULL_URI - Full Docker image URI for substitution (optional)
#   TARGET_REGISTRY - Target registry for substitution (optional)
#   TARGET_BASE_PATH - Target base path for substitution (optional)
#   IS_RELEASE      - Release flag for substitution (optional)
#   SUBSTITUTION_TOKEN_STYLE - Token delimiter syntax (default: shell)
#   TOKEN_NAME_STYLE - Case style for token names (default: PascalCase)
#   TOKEN_NAME_VALIDATION - How to validate user token names (default: MATCH)
#   ALLOW_BUILTIN_TOKEN_OVERRIDE - Allow user tokens to override built-ins (default: false)
#   CONFIG_SUB_PATH - Source directory for user-defined tokens, relative (default: src/config)
#   CONFIG_VALUE_TRAILING_NEWLINE - Trailing newline handling (default: strip-for-single-line)
#
# Outputs:
#   MANIFESTS_ZIP_SUB_PATH - Relative path to directory containing the zip file
#   MANIFESTS_ZIP_FILE_NAME - Filename of zip
#
set -euo pipefail

# Locate script directory for calling sibling scripts
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PLUGINS_DIR="${SCRIPT_DIR}/../plugins"

# Logging configuration (CI-agnostic)
LOG_ERROR_PREFIX="${LOG_ERROR_PREFIX:-}"
LOG_ERROR_SUFFIX="${LOG_ERROR_SUFFIX:-}"

# Required inputs
PROJECT_NAME="${PROJECT_NAME:?PROJECT_NAME is required}"
VERSION="${VERSION:?VERSION is required}"

# Optional inputs with defaults (sub-paths are relative)
MANIFESTS_SUB_PATH="${MANIFESTS_SUB_PATH:-src/kubernetes}"
OUTPUT_SUB_PATH="${OUTPUT_SUB_PATH:-target}"
DOCKER_TAG="${DOCKER_TAG:-}"
DOCKER_IMAGE_NAME="${DOCKER_IMAGE_NAME:-}"
DOCKER_IMAGE_FULL_URI="${DOCKER_IMAGE_FULL_URI:-}"
TARGET_REGISTRY="${TARGET_REGISTRY:-}"
TARGET_BASE_PATH="${TARGET_BASE_PATH:-}"
IS_RELEASE="${IS_RELEASE:-}"
SUBSTITUTION_TOKEN_STYLE="${SUBSTITUTION_TOKEN_STYLE:-shell}"
TOKEN_NAME_STYLE="${TOKEN_NAME_STYLE:-PascalCase}"
TOKEN_NAME_VALIDATION="${TOKEN_NAME_VALIDATION:-MATCH}"
ALLOW_BUILTIN_TOKEN_OVERRIDE="${ALLOW_BUILTIN_TOKEN_OVERRIDE:-false}"
CONFIG_SUB_PATH="${CONFIG_SUB_PATH:-src/config}"
CONFIG_VALUE_TRAILING_NEWLINE="${CONFIG_VALUE_TRAILING_NEWLINE:-strip-for-single-line}"

# Build output structure (sub-paths, relative to working directory)
MANIFESTS_RAW_SUB_PATH="${OUTPUT_SUB_PATH}/manifests/raw"
MANIFESTS_CONFIG_SUB_PATH="${OUTPUT_SUB_PATH}/manifests/config"
MANIFESTS_SUBSTITUTED_SUB_PATH="${OUTPUT_SUB_PATH}/manifests/substituted"
MANIFESTS_ZIP_SUB_PATH="${OUTPUT_SUB_PATH}/manifests/zip"

# Output variable for GitHub Actions
output_var() {
  local name="$1"
  local value="$2"

  echo "${name}=${value}"

  if [[ -n "${GITHUB_OUTPUT:-}" ]]; then
    echo "${name}=${value}" >> "${GITHUB_OUTPUT}"
  fi
}

# Case conversion functions - translate UPPER_SNAKE to target style
to_upper_snake() {
  echo "$1"  # Already in UPPER_SNAKE
}

to_lower_snake() {
  echo "$1" | tr '[:upper:]' '[:lower:]'
}

to_kebab_case() {
  echo "$1" | tr '[:upper:]_' '[:lower:]-'
}

to_camel_case() {
  local input="$1"
  local result=""
  local capitalize=false

  input=$(echo "${input}" | tr '[:upper:]' '[:lower:]')

  for (( i=0; i<${#input}; i++ )); do
    local char="${input:$i:1}"
    if [[ "${char}" == "_" ]]; then
      capitalize=true
    elif [[ "${capitalize}" == "true" ]]; then
      result+=$(echo "${char}" | tr '[:lower:]' '[:upper:]')
      capitalize=false
    else
      result+="${char}"
    fi
  done

  echo "${result}"
}

to_pascal_case() {
  local camel
  camel=$(to_camel_case "$1")
  echo "$(echo "${camel:0:1}" | tr '[:lower:]' '[:upper:]')${camel:1}"
}

to_lower_dot() {
  echo "$1" | tr '[:upper:]_' '[:lower:].'
}

to_upper_dot() {
  echo "$1" | tr '_' '.'
}

# Translate variable name from UPPER_SNAKE to configured style
translate_var_name() {
  local var_name="$1"

  case "${TOKEN_NAME_STYLE}" in
    UPPER_SNAKE)  to_upper_snake "${var_name}" ;;
    lower_snake)  to_lower_snake "${var_name}" ;;
    kebab-case)   to_kebab_case "${var_name}" ;;
    camelCase)    to_camel_case "${var_name}" ;;
    PascalCase)   to_pascal_case "${var_name}" ;;
    lower.dot)    to_lower_dot "${var_name}" ;;
    UPPER.DOT)    to_upper_dot "${var_name}" ;;
    *)
      echo "${LOG_ERROR_PREFIX}Unknown token name style: ${TOKEN_NAME_STYLE}${LOG_ERROR_SUFFIX}" >&2
      exit 1
      ;;
  esac
}

# Write a built-in token file
write_builtin_token() {
  local name="$1"
  local value="$2"
  local target_name
  target_name=$(translate_var_name "${name}")

  printf '%s' "${value}" > "${MANIFESTS_CONFIG_SUB_PATH}/${target_name}"
}

# Get validator script for a style
get_validator_script() {
  local style="$1"
  echo "${PLUGINS_DIR}/token-name-validators/${style}"
}

main() {
  echo "=== Kubernetes Manifest Package ===" >&2
  echo "Source: ${MANIFESTS_SUB_PATH}" >&2
  echo "Config: ${CONFIG_SUB_PATH}" >&2
  echo "Output: ${OUTPUT_SUB_PATH}" >&2
  echo "Project: ${PROJECT_NAME}" >&2
  echo "Version: ${VERSION}" >&2
  [[ -n "${DOCKER_TAG}" ]] && echo "Docker tag: ${DOCKER_TAG}" >&2
  [[ -n "${DOCKER_IMAGE_NAME}" ]] && echo "Docker image: ${DOCKER_IMAGE_NAME}" >&2
  echo "Token style: ${SUBSTITUTION_TOKEN_STYLE}" >&2
  echo "Name style: ${TOKEN_NAME_STYLE}" >&2
  echo "Name validation: ${TOKEN_NAME_VALIDATION}" >&2
  echo "Allow override: ${ALLOW_BUILTIN_TOKEN_OVERRIDE}" >&2
  echo "Trailing newline: ${CONFIG_VALUE_TRAILING_NEWLINE}" >&2
  echo "====================================" >&2

  # Validate manifests directory exists
  if [[ ! -d "${MANIFESTS_SUB_PATH}" ]]; then
    echo "${LOG_ERROR_PREFIX}Manifests directory not found: ${MANIFESTS_SUB_PATH}${LOG_ERROR_SUFFIX}" >&2
    exit 1
  fi

  # Count files by type
  local yaml_count=0
  local other_count=0
  local total_files=0

  while IFS= read -r file; do
    total_files=$((total_files + 1))
    case "${file}" in
      *.yaml|*.yml) yaml_count=$((yaml_count + 1)) ;;
      *) other_count=$((other_count + 1)) ;;
    esac
  done < <(find "${MANIFESTS_SUB_PATH}" -type f)

  if [[ "${total_files}" -eq 0 ]]; then
    echo "${LOG_ERROR_PREFIX}Manifests directory is empty: ${MANIFESTS_SUB_PATH}${LOG_ERROR_SUFFIX}" >&2
    exit 1
  fi

  echo "" >&2
  echo "Found ${yaml_count} manifest file(s) (.yaml/.yml)" >&2
  if [[ ${other_count} -gt 0 ]]; then
    echo "Found ${other_count} non-manifest file(s)" >&2
  fi

  # Create output directory structure
  mkdir -p "${MANIFESTS_RAW_SUB_PATH}"
  mkdir -p "${MANIFESTS_CONFIG_SUB_PATH}"
  mkdir -p "${MANIFESTS_ZIP_SUB_PATH}"

  # Copy to raw (preserving original)
  cp -R "${MANIFESTS_SUB_PATH}"/* "${MANIFESTS_RAW_SUB_PATH}/"

  # Step 1: Write built-in tokens as files
  echo "" >&2
  echo "Writing built-in tokens..." >&2
  write_builtin_token "PROJECT_NAME" "${PROJECT_NAME}"
  write_builtin_token "VERSION" "${VERSION}"
  if [[ -n "${DOCKER_TAG}" ]]; then
    write_builtin_token "DOCKER_TAG" "${DOCKER_TAG}"
  fi
  if [[ -n "${DOCKER_IMAGE_NAME}" ]]; then
    write_builtin_token "DOCKER_IMAGE_NAME" "${DOCKER_IMAGE_NAME}"
  fi
  if [[ -n "${DOCKER_IMAGE_FULL_URI}" ]]; then
    write_builtin_token "DOCKER_IMAGE_FULL_URI" "${DOCKER_IMAGE_FULL_URI}"
  fi
  if [[ -n "${TARGET_REGISTRY}" ]]; then
    write_builtin_token "TARGET_REGISTRY" "${TARGET_REGISTRY}"
  fi
  if [[ -n "${TARGET_BASE_PATH}" ]]; then
    write_builtin_token "TARGET_BASE_PATH" "${TARGET_BASE_PATH}"
  fi
  write_builtin_token "IS_RELEASE" "${IS_RELEASE}"
  # Computed token - available before substitution
  local zip_name="${PROJECT_NAME}-${VERSION}-manifests.zip"
  write_builtin_token "MANIFESTS_ZIP_FILE_NAME" "${zip_name}"

  # Step 2: Validate user config if it exists
  if [[ -d "${CONFIG_SUB_PATH}" ]] && [[ -n "$(find "${CONFIG_SUB_PATH}" -type f 2>/dev/null)" ]]; then
    echo "Validating user config tokens..." >&2

    # Determine which validator to use
    local validator_style
    if [[ "${TOKEN_NAME_VALIDATION}" == "MATCH" ]]; then
      validator_style="${TOKEN_NAME_STYLE}"
    else
      validator_style="ALL"
    fi

    local validator_script
    validator_script=$(get_validator_script "${validator_style}")

    if [[ ! -x "${validator_script}" ]]; then
      echo "${LOG_ERROR_PREFIX}Validator not found: ${validator_style}${LOG_ERROR_SUFFIX}" >&2
      exit 1
    fi

    # Run validator
    if ! "${validator_script}" "${CONFIG_SUB_PATH}"; then
      exit 1
    fi

    # Step 3: Check for conflicts with built-in tokens
    if [[ "${ALLOW_BUILTIN_TOKEN_OVERRIDE}" != "true" ]]; then
      local conflicts=()

      while IFS= read -r -d '' user_file; do
        local user_token="${user_file#"${CONFIG_SUB_PATH}"/}"
        # Check if this token name matches any built-in
        if [[ -f "${MANIFESTS_CONFIG_SUB_PATH}/${user_token}" ]]; then
          conflicts+=("${user_token}")
        fi
      done < <(find "${CONFIG_SUB_PATH}" -type f -print0)

      if [[ ${#conflicts[@]} -gt 0 ]]; then
        echo "${LOG_ERROR_PREFIX}Found attempt to override built-in variable(s) - this is not allowed:${LOG_ERROR_SUFFIX}" >&2
        for conflict in "${conflicts[@]}"; do
          echo "  ${conflict}" >&2
        done
        exit 1
      fi
    fi

    # Step 4: Copy user config to output (may override built-ins if allowed)
    echo "Copying user config tokens..." >&2
    cp -R "${CONFIG_SUB_PATH}"/* "${MANIFESTS_CONFIG_SUB_PATH}/"
  fi

  # Step 5: Copy manifests to substituted/<project-name>/
  echo "" >&2
  echo "Preparing manifests for substitution..." >&2
  mkdir -p "${MANIFESTS_SUBSTITUTED_SUB_PATH}/${PROJECT_NAME}"
  cp -R "${MANIFESTS_SUB_PATH}"/* "${MANIFESTS_SUBSTITUTED_SUB_PATH}/${PROJECT_NAME}/"

  # Step 6: Perform variable substitution
  echo "Performing variable substitution..." >&2
  CONFIG_VALUE_TRAILING_NEWLINE="${CONFIG_VALUE_TRAILING_NEWLINE}" \
  "${SCRIPT_DIR}/substitute-tokens-from-dir" \
    "${SUBSTITUTION_TOKEN_STYLE}" \
    "${MANIFESTS_CONFIG_SUB_PATH}" \
    "${MANIFESTS_SUBSTITUTED_SUB_PATH}/${PROJECT_NAME}"

  # Step 7: Create zip directly from substituted (project-name wrapper already in place)
  echo "" >&2
  echo "Creating zip: ${MANIFESTS_ZIP_SUB_PATH}/${zip_name}" >&2
  # Capture repo root first since this command cds somewhere else

  local repo_root="$(pwd)"
  (cd "${MANIFESTS_SUBSTITUTED_SUB_PATH}" && zip -rq "${repo_root}/${MANIFESTS_ZIP_SUB_PATH}/${zip_name}" "${PROJECT_NAME}")

  # Verify zip was created
  if [[ ! -f "${MANIFESTS_ZIP_SUB_PATH}/${zip_name}" ]]; then
    echo "${LOG_ERROR_PREFIX}Failed to create zip file${LOG_ERROR_SUFFIX}" >&2
    exit 1
  fi

  local zip_size
  zip_size=$(wc -c < "${MANIFESTS_ZIP_SUB_PATH}/${zip_name}" | tr -d ' ')
  echo "Created: ${zip_name} (${zip_size} bytes)" >&2

  output_var "MANIFESTS_ZIP_SUB_PATH" "${MANIFESTS_ZIP_SUB_PATH}"
  output_var "MANIFESTS_ZIP_FILE_NAME" "${zip_name}"

  echo "" >&2
  echo "=== Package Complete ===" >&2
}

main "$@"
