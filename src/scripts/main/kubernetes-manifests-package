#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025 Kaptain contributors (Fred Cooke)
#
# kubernetes-manifest-package - Packages Kubernetes manifests into a zip with variable substitution
#
# Inputs (environment variables):
#   MANIFESTS_SUB_PATH  - Source directory, relative (default: src/kubernetes)
#   PROJECT_NAME    - For variable substitution (required)
#   VERSION         - For variable substitution (required)
#   OUTPUT_SUB_PATH - Build output directory, relative (default: target)
#   DOCKER_TAG      - Docker tag for substitution (optional)
#   DOCKER_IMAGE_NAME - Docker image name for substitution (optional)
#   DOCKER_IMAGE_FULL_URI - Full Docker image URI for substitution (optional)
#   TARGET_REGISTRY - Target registry for substitution (optional)
#   TARGET_BASE_PATH - Target base path for substitution (optional)
#   IS_RELEASE      - Release flag for substitution (optional)
#   SUBSTITUTION_TOKEN_STYLE - Token delimiter syntax (default: shell)
#   TOKEN_NAME_STYLE - Case style for token names (default: PascalCase)
#   TOKEN_NAME_VALIDATION - How to validate user token names (default: MATCH)
#   ALLOW_BUILTIN_TOKEN_OVERRIDE - Allow user tokens to override built-ins (default: false)
#   CONFIG_SUB_PATH - Source directory for user-defined tokens, relative (default: src/config)
#   CONFIG_VALUE_TRAILING_NEWLINE - Trailing newline handling (default: strip-for-single-line)
#
# Outputs:
#   MANIFESTS_ZIP_SUB_PATH - Relative path to directory containing the zip file
#   MANIFESTS_ZIP_FILE_NAME - Filename of zip
#
set -euo pipefail

# Locate script directory for calling sibling scripts
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Logging configuration (CI-agnostic)
LOG_ERROR_PREFIX="${LOG_ERROR_PREFIX:-}"
LOG_ERROR_SUFFIX="${LOG_ERROR_SUFFIX:-}"

# Required inputs
PROJECT_NAME="${PROJECT_NAME:?PROJECT_NAME is required}"
VERSION="${VERSION:?VERSION is required}"

# Optional inputs with defaults (sub-paths are relative)
MANIFESTS_SUB_PATH="${MANIFESTS_SUB_PATH:-src/kubernetes}"
OUTPUT_SUB_PATH="${OUTPUT_SUB_PATH:-target}"
DOCKER_TAG="${DOCKER_TAG:-}"
DOCKER_IMAGE_NAME="${DOCKER_IMAGE_NAME:-}"
DOCKER_IMAGE_FULL_URI="${DOCKER_IMAGE_FULL_URI:-}"
TARGET_REGISTRY="${TARGET_REGISTRY:-}"
TARGET_BASE_PATH="${TARGET_BASE_PATH:-}"
IS_RELEASE="${IS_RELEASE:-}"
SUBSTITUTION_TOKEN_STYLE="${SUBSTITUTION_TOKEN_STYLE:-shell}"
TOKEN_NAME_STYLE="${TOKEN_NAME_STYLE:-PascalCase}"
TOKEN_NAME_VALIDATION="${TOKEN_NAME_VALIDATION:-MATCH}"
ALLOW_BUILTIN_TOKEN_OVERRIDE="${ALLOW_BUILTIN_TOKEN_OVERRIDE:-false}"
CONFIG_SUB_PATH="${CONFIG_SUB_PATH:-src/config}"
CONFIG_VALUE_TRAILING_NEWLINE="${CONFIG_VALUE_TRAILING_NEWLINE:-strip-for-single-line}"

# Build output structure (sub-paths, relative to working directory)
MANIFESTS_RAW_SUB_PATH="${OUTPUT_SUB_PATH}/manifests/raw"
MANIFESTS_CONFIG_SUB_PATH="${OUTPUT_SUB_PATH}/manifests/config"
MANIFESTS_SUBSTITUTED_SUB_PATH="${OUTPUT_SUB_PATH}/manifests/substituted"
MANIFESTS_ZIP_SUB_PATH="${OUTPUT_SUB_PATH}/manifests/zip"

# Output variable for GitHub Actions
output_var() {
  local name="$1"
  local value="$2"

  echo "${name}=${value}"

  if [[ -n "${GITHUB_OUTPUT:-}" ]]; then
    echo "${name}=${value}" >> "${GITHUB_OUTPUT}"
  fi
}

main() {
  echo "=== Kubernetes Manifest Package ===" >&2
  echo "Source: ${MANIFESTS_SUB_PATH}" >&2
  echo "Config: ${CONFIG_SUB_PATH}" >&2
  echo "Output: ${OUTPUT_SUB_PATH}" >&2
  echo "Project: ${PROJECT_NAME}" >&2
  echo "Version: ${VERSION}" >&2
  [[ -n "${DOCKER_TAG}" ]] && echo "Docker tag: ${DOCKER_TAG}" >&2
  [[ -n "${DOCKER_IMAGE_NAME}" ]] && echo "Docker image: ${DOCKER_IMAGE_NAME}" >&2
  echo "Token style: ${SUBSTITUTION_TOKEN_STYLE}" >&2
  echo "Name style: ${TOKEN_NAME_STYLE}" >&2
  echo "Name validation: ${TOKEN_NAME_VALIDATION}" >&2
  echo "Allow override: ${ALLOW_BUILTIN_TOKEN_OVERRIDE}" >&2
  echo "Trailing newline: ${CONFIG_VALUE_TRAILING_NEWLINE}" >&2
  echo "====================================" >&2

  # Validate manifests directory exists
  if [[ ! -d "${MANIFESTS_SUB_PATH}" ]]; then
    echo "${LOG_ERROR_PREFIX}Manifests directory not found: ${MANIFESTS_SUB_PATH}${LOG_ERROR_SUFFIX}" >&2
    exit 1
  fi

  # Count files by type
  local yaml_count=0
  local other_count=0
  local total_files=0

  while IFS= read -r file; do
    total_files=$((total_files + 1))
    case "${file}" in
      *.yaml|*.yml) yaml_count=$((yaml_count + 1)) ;;
      *) other_count=$((other_count + 1)) ;;
    esac
  done < <(find "${MANIFESTS_SUB_PATH}" -type f)

  if [[ "${total_files}" -eq 0 ]]; then
    echo "${LOG_ERROR_PREFIX}Manifests directory is empty: ${MANIFESTS_SUB_PATH}${LOG_ERROR_SUFFIX}" >&2
    exit 1
  fi

  echo "" >&2
  echo "Found ${yaml_count} manifest file(s) (.yaml/.yml)" >&2
  if [[ ${other_count} -gt 0 ]]; then
    echo "Found ${other_count} non-manifest file(s)" >&2
  fi

  # Create output directory structure
  mkdir -p "${MANIFESTS_RAW_SUB_PATH}"
  mkdir -p "${MANIFESTS_ZIP_SUB_PATH}"

  # Copy to raw (preserving original)
  cp -R "${MANIFESTS_SUB_PATH}"/* "${MANIFESTS_RAW_SUB_PATH}/"

  # Compute the zip filename (used as a built-in token)
  local zip_name="${PROJECT_NAME}-${VERSION}-manifests.zip"

  # Prepare substitution tokens (built-ins + user config)
  echo "" >&2
  TOKENS_OUTPUT_SUB_PATH="${MANIFESTS_CONFIG_SUB_PATH}" \
  CONFIG_SUB_PATH="${CONFIG_SUB_PATH}" \
  TOKEN_NAME_STYLE="${TOKEN_NAME_STYLE}" \
  TOKEN_NAME_VALIDATION="${TOKEN_NAME_VALIDATION}" \
  ALLOW_BUILTIN_TOKEN_OVERRIDE="${ALLOW_BUILTIN_TOKEN_OVERRIDE}" \
  CONFIG_VALUE_TRAILING_NEWLINE="${CONFIG_VALUE_TRAILING_NEWLINE}" \
  PROJECT_NAME="${PROJECT_NAME}" \
  VERSION="${VERSION}" \
  DOCKER_TAG="${DOCKER_TAG}" \
  DOCKER_IMAGE_NAME="${DOCKER_IMAGE_NAME}" \
  DOCKER_IMAGE_FULL_URI="${DOCKER_IMAGE_FULL_URI}" \
  TARGET_REGISTRY="${TARGET_REGISTRY}" \
  TARGET_BASE_PATH="${TARGET_BASE_PATH}" \
  IS_RELEASE="${IS_RELEASE}" \
  MANIFESTS_ZIP_FILE_NAME="${zip_name}" \
  "${SCRIPT_DIR}/prepare-substitution-tokens"

  # Copy manifests to substituted/<project-name>/
  echo "" >&2
  echo "Preparing manifests for substitution..." >&2
  mkdir -p "${MANIFESTS_SUBSTITUTED_SUB_PATH}/${PROJECT_NAME}"
  cp -R "${MANIFESTS_SUB_PATH}"/* "${MANIFESTS_SUBSTITUTED_SUB_PATH}/${PROJECT_NAME}/"

  # Perform variable substitution
  echo "Performing variable substitution..." >&2
  CONFIG_VALUE_TRAILING_NEWLINE="${CONFIG_VALUE_TRAILING_NEWLINE}" \
  "${SCRIPT_DIR}/substitute-tokens-from-dir" \
    "${SUBSTITUTION_TOKEN_STYLE}" \
    "${MANIFESTS_CONFIG_SUB_PATH}" \
    "${MANIFESTS_SUBSTITUTED_SUB_PATH}/${PROJECT_NAME}"

  # Create zip directly from substituted (project-name wrapper already in place)
  echo "" >&2
  echo "Creating zip: ${MANIFESTS_ZIP_SUB_PATH}/${zip_name}" >&2
  # Capture repo root first since this command cds somewhere else

  local repo_root
  repo_root="$(pwd)"
  (cd "${MANIFESTS_SUBSTITUTED_SUB_PATH}" && zip -rq "${repo_root}/${MANIFESTS_ZIP_SUB_PATH}/${zip_name}" "${PROJECT_NAME}")

  # Verify zip was created
  if [[ ! -f "${MANIFESTS_ZIP_SUB_PATH}/${zip_name}" ]]; then
    echo "${LOG_ERROR_PREFIX}Failed to create zip file${LOG_ERROR_SUFFIX}" >&2
    exit 1
  fi

  local zip_size
  zip_size=$(wc -c < "${MANIFESTS_ZIP_SUB_PATH}/${zip_name}" | tr -d ' ')
  echo "Created: ${zip_name} (${zip_size} bytes)" >&2

  output_var "MANIFESTS_ZIP_SUB_PATH" "${MANIFESTS_ZIP_SUB_PATH}"
  output_var "MANIFESTS_ZIP_FILE_NAME" "${zip_name}"

  echo "" >&2
  echo "=== Package Complete ===" >&2
}

main "$@"
