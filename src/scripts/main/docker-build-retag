#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025-2026 Kaptain contributors (Fred Cooke)
#
# docker-build-retag - Pulls and retags Docker images (no push)
#
# Inputs (environment variables):
# User set inputs (validate):
#   DOCKER_SOURCE_REGISTRY       - Source registry (e.g., docker.io)
#   DOCKER_SOURCE_NAMESPACE      - Namespace between registry and image name (optional, e.g., library)
#   DOCKER_SOURCE_IMAGE_NAME     - Source image name (e.g., nginx)
#   DOCKER_SOURCE_TAG            - Source image tag (e.g., 1.25)
#   DOCKER_TARGET_REGISTRY       - Target registry (e.g., ghcr.io)
#   DOCKER_TARGET_NAMESPACE      - Namespace between registry and image name (optional)
# System generated:
#   DOCKER_IMAGE_NAME            - Target image name (from version generator)
#   DOCKER_TAG                   - Target tag (from version generator)
#
# Outputs:
#   DOCKER_SOURCE_IMAGE_FULL_URI - Full source image reference
#   DOCKER_TARGET_IMAGE_FULL_URI - Full target image reference
#
set -euo pipefail

# Locate script directory for sourcing shared scripts
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Logging configuration (CI-agnostic)
LOG_ERROR_PREFIX="${LOG_ERROR_PREFIX:-}"
LOG_ERROR_SUFFIX="${LOG_ERROR_SUFFIX:-}"
LOG_WARNING_PREFIX="${LOG_WARNING_PREFIX:-}"
LOG_WARNING_SUFFIX="${LOG_WARNING_SUFFIX:-}"

# shellcheck source=src/scripts/defaults/docker-push-image-list.bash
source "${SCRIPT_DIR}/../defaults/docker-push-image-list.bash"
# shellcheck source=src/scripts/defaults/docker-build.bash
source "${SCRIPT_DIR}/../defaults/docker-build.bash"
# shellcheck source=src/scripts/defaults/docker-retag.bash
source "${SCRIPT_DIR}/../defaults/docker-retag.bash"
# shellcheck source=src/scripts/defaults/docker-common.bash
source "${SCRIPT_DIR}/../defaults/docker-common.bash"
# shellcheck source=src/scripts/defaults/output-sub-path.bash
source "${SCRIPT_DIR}/../defaults/output-sub-path.bash"
# shellcheck source=src/scripts/lib/output-var.bash
source "${SCRIPT_DIR}/../lib/output-var.bash"

# Validate required inputs
if [[ -z "${DOCKER_SOURCE_REGISTRY}" ]]; then
  echo "${LOG_ERROR_PREFIX}DOCKER_SOURCE_REGISTRY is required${LOG_ERROR_SUFFIX}" >&2
  exit 1
fi
if [[ -z "${DOCKER_SOURCE_IMAGE_NAME}" ]]; then
  echo "${LOG_ERROR_PREFIX}DOCKER_SOURCE_IMAGE_NAME is required${LOG_ERROR_SUFFIX}" >&2
  exit 1
fi
if [[ -z "${DOCKER_SOURCE_TAG}" ]]; then
  echo "${LOG_ERROR_PREFIX}DOCKER_SOURCE_TAG is required${LOG_ERROR_SUFFIX}" >&2
  exit 1
fi

# Source registry cannot contain slashes
if [[ "${SOURCE_REGISTRY}" == */* ]]; then
  echo "${LOG_ERROR_PREFIX}DOCKER_SOURCE_REGISTRY cannot contain slashes - use DOCKER_SOURCE_NAMESPACE for paths${LOG_ERROR_SUFFIX}" >&2
  exit 1
fi

# Strip leading/trailing slashes from source image name (internal slashes are valid)
SOURCE_IMAGE_NAME="${INPUT_SOURCE_IMAGE_NAME#/}"
SOURCE_IMAGE_NAME="${SOURCE_IMAGE_NAME%/}"
if [[ "${INPUT_SOURCE_IMAGE_NAME}" != "${SOURCE_IMAGE_NAME}" ]]; then
  echo "${LOG_WARNING_PREFIX}DOCKER_SOURCE_IMAGE_NAME has leading/trailing slashes. Stripping.${LOG_WARNING_SUFFIX}" >&2
fi

# Strip leading/trailing slashes from source namespace
SOURCE_NAMESPACE="${INPUT_SOURCE_NAMESPACE#/}"
SOURCE_NAMESPACE="${SOURCE_NAMESPACE%/}"
if [[ "${INPUT_SOURCE_NAMESPACE}" != "${SOURCE_NAMESPACE}" ]]; then
  echo "${LOG_WARNING_PREFIX}DOCKER_SOURCE_NAMESPACE has leading/trailing slashes. Stripping.${LOG_WARNING_SUFFIX}" >&2
fi

# === Assemble source image URI ===
if [[ -n "${SOURCE_NAMESPACE}" ]]; then
  SOURCE_IMAGE_FULL_URI="${SOURCE_REGISTRY}/${SOURCE_NAMESPACE}/${SOURCE_IMAGE_NAME}:${SOURCE_TAG}"
else
  SOURCE_IMAGE_FULL_URI="${SOURCE_REGISTRY}/${SOURCE_IMAGE_NAME}:${SOURCE_TAG}"
fi

# === Shared target validation, URI assembly, and utilities ===
# shellcheck source=src/scripts/lib/docker-build-shared.bash
source "${SCRIPT_DIR}/../lib/docker-build-shared.bash"

main() {
  echo "=== Docker Retag ===" >&2
  echo "Source: ${SOURCE_IMAGE_FULL_URI}" >&2
  echo "Target: ${TARGET_IMAGE_FULL_URI}" >&2
  echo "Platform: ${DOCKER_PLATFORM}" >&2
  echo "====================" >&2

  if [[ "${DOCKER_PLATFORM}" == *,* ]]; then
    # === Multi-platform retag ===
    IFS=',' read -ra platforms <<< "${DOCKER_PLATFORM}"
    local manifest_uris_file="${OUTPUT_SUB_PATH}/docker-push-all/manifest-uris"
    mkdir -p "$(dirname "${manifest_uris_file}")"

    for platform in "${platforms[@]}"; do
      local platform_suffix="${platform//\//-}"
      local arch_uri="${TARGET_IMAGE_FULL_URI}-${platform_suffix}"

      echo "Pulling source image: ${SOURCE_IMAGE_FULL_URI} (platform: ${platform})" >&2
      if ! ${IMAGE_BUILD_COMMAND} pull --platform "${platform}" "${SOURCE_IMAGE_FULL_URI}"; then
        echo "${LOG_ERROR_PREFIX}Source image does not support platform ${platform}: ${SOURCE_IMAGE_FULL_URI}${LOG_ERROR_SUFFIX}" >&2
        exit 1
      fi

      # Confirm arch-specific target doesn't exist (fail fast)
      if ${IMAGE_BUILD_COMMAND} manifest inspect "${arch_uri}" &>/dev/null; then
        echo "${LOG_ERROR_PREFIX}Target image already exists in registry: ${arch_uri}${LOG_ERROR_SUFFIX}" >&2
        exit 1
      fi
      echo "Confirmed target image does not exist in registry: ${arch_uri}" >&2

      echo "Tagging: ${SOURCE_IMAGE_FULL_URI} -> ${arch_uri}" >&2
      ${IMAGE_BUILD_COMMAND} tag "${SOURCE_IMAGE_FULL_URI}" "${arch_uri}"

      # Register arch-specific image for consolidated push
      echo "${arch_uri}" >> "${DOCKER_PUSH_IMAGE_LIST_FILE}"
    done

    # Register base URI for manifest list creation
    echo "${TARGET_IMAGE_FULL_URI}" >> "${manifest_uris_file}"

    output_var "DOCKER_SOURCE_IMAGE_FULL_URI" "${SOURCE_IMAGE_FULL_URI}"
    output_var "DOCKER_TARGET_IMAGE_FULL_URI" "${TARGET_IMAGE_FULL_URI}"
  else
    # === Single-platform retag ===
    echo "Pulling source image: ${SOURCE_IMAGE_FULL_URI} (platform: ${DOCKER_PLATFORM})" >&2
    ${IMAGE_BUILD_COMMAND} pull --platform "${DOCKER_PLATFORM}" "${SOURCE_IMAGE_FULL_URI}"

    # Confirm target doesn't exist (fail fast)
    confirm_target_image_doesnt_exist || exit 1

    echo "Tagging: ${SOURCE_IMAGE_FULL_URI} -> ${TARGET_IMAGE_FULL_URI}" >&2
    ${IMAGE_BUILD_COMMAND} tag "${SOURCE_IMAGE_FULL_URI}" "${TARGET_IMAGE_FULL_URI}"

    output_var "DOCKER_SOURCE_IMAGE_FULL_URI" "${SOURCE_IMAGE_FULL_URI}"
    output_var "DOCKER_TARGET_IMAGE_FULL_URI" "${TARGET_IMAGE_FULL_URI}"

    # Register image for consolidated push
    echo "${TARGET_IMAGE_FULL_URI}" >> "${DOCKER_PUSH_IMAGE_LIST_FILE}"
  fi

  echo "Docker Retag complete" >&2
}

main "$@"
