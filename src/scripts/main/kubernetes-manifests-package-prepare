#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025-2026 Kaptain contributors (Fred Cooke)
#
# kubernetes-manifests-package-prepare - Prepares manifests and tokens for packaging
#
# Sets up directory structure, copies source manifests, prepares substitution tokens.
# Called before kubernetes-manifests-package (the "do" step).
#
# Inputs (environment variables):
#   MANIFESTS_SUB_PATH  - Source directory, relative (default: src/kubernetes)
#   PROJECT_NAME    - For variable substitution (required)
#   VERSION         - For variable substitution (required)
#   OUTPUT_SUB_PATH - Build output directory, relative (default: target)
#   DOCKER_TAG      - Docker tag for substitution (required)
#   DOCKER_IMAGE_NAME - Docker image name for substitution (required)
#   DOCKER_IMAGE_FULL_URI - Full Docker image URI for substitution (optional)
#   TARGET_REGISTRY - Target registry for substitution (optional)
#   TARGET_NAMESPACE - Target namespace for substitution (optional)
#   IS_RELEASE      - Release flag for substitution (optional)
#   TOKEN_DELIMITER_STYLE - Token delimiter syntax (default: shell)
#   TOKEN_NAME_STYLE - Case style for token names (default: PascalCase)
#   TOKEN_NAME_VALIDATION - How to validate user token names (default: MATCH)
#   ALLOW_BUILTIN_TOKEN_OVERRIDE - Allow user tokens to override built-ins (default: false)
#   CONFIG_SUB_PATH - Source directory for user-defined tokens, relative (default: src/config)
#   CONFIG_VALUE_TRAILING_NEWLINE - Trailing newline handling (default: strip-for-single-line)
#
# Outputs:
#   MANIFESTS_ZIP_FILE_NAME - Filename of zip (for subsequent steps)
#
set -euo pipefail

# Locate script directory for calling sibling scripts
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Required inputs
PROJECT_NAME="${PROJECT_NAME:?PROJECT_NAME is required}"
VERSION="${VERSION:?VERSION is required}"
DOCKER_TAG="${DOCKER_TAG:?DOCKER_TAG is required}"
DOCKER_IMAGE_NAME="${DOCKER_IMAGE_NAME:?DOCKER_IMAGE_NAME is required}"

# shellcheck source=src/scripts/defaults/output-sub-path.bash
source "$(dirname "${BASH_SOURCE[0]}")/../defaults/output-sub-path.bash"
# shellcheck source=src/scripts/defaults/platform.bash
source "${SCRIPT_DIR}/../defaults/platform.bash"
# shellcheck source=src/scripts/defaults/manifests-sub-path.bash
source "$(dirname "${BASH_SOURCE[0]}")/../defaults/manifests-sub-path.bash"

# Pass-through vars (called scripts default their own; these just satisfy set -u)
DOCKER_IMAGE_FULL_URI="${DOCKER_IMAGE_FULL_URI:-}"
TARGET_REGISTRY="${TARGET_REGISTRY:-}"
TARGET_NAMESPACE="${TARGET_NAMESPACE:-}"
IS_RELEASE="${IS_RELEASE:-}"
# Token substitution
# shellcheck source=src/scripts/defaults/tokens.bash
source "$(dirname "${BASH_SOURCE[0]}")/../defaults/tokens.bash"

# shellcheck source=src/scripts/lib/output-var.bash
source "${SCRIPT_DIR}/../lib/output-var.bash"
# shellcheck source=src/scripts/lib/log.bash
source "${SCRIPT_DIR}/../lib/log.bash"

# Build output structure (sub-paths, relative to working directory)
MANIFESTS_COMBINED_SUB_PATH="${OUTPUT_SUB_PATH}/manifests/combined"
MANIFESTS_CONFIG_SUB_PATH="${OUTPUT_SUB_PATH}/manifests/config"
MANIFESTS_ZIP_SUB_PATH="${OUTPUT_SUB_PATH}/manifests/zip"

main() {
  log "=== Kubernetes Manifest Package Prepare ==="
  log "Source: ${MANIFESTS_SUB_PATH}"
  log "Config: ${CONFIG_SUB_PATH}"
  log "Output: ${OUTPUT_SUB_PATH}"
  log "Project: ${PROJECT_NAME}"
  log "Version: ${VERSION}"
  log "Docker tag: ${DOCKER_TAG}"
  log "Docker image: ${DOCKER_IMAGE_NAME}"
  log "============================================"

  # Create output directory structure (may already exist from pre-package hooks)
  mkdir -p "${MANIFESTS_COMBINED_SUB_PATH}"
  mkdir -p "${MANIFESTS_ZIP_SUB_PATH}"

  # Copy from source to combined if source exists and has files
  # (Hooks may have already contributed to combined/ - source files override)
  if [[ -d "${MANIFESTS_SUB_PATH}" ]]; then
    local source_file_count
    source_file_count=$(find "${MANIFESTS_SUB_PATH}" -type f | wc -l | tr -d ' ')

    if [[ "${source_file_count}" -gt 0 ]]; then
      log ""
      log "Copying ${source_file_count} file(s) from ${MANIFESTS_SUB_PATH}"
      cp -R "${MANIFESTS_SUB_PATH}"/* "${MANIFESTS_COMBINED_SUB_PATH}/"
    else
      log ""
      log "Source directory empty: ${MANIFESTS_SUB_PATH}"
    fi
  else
    log ""
    log "Source directory not found: ${MANIFESTS_SUB_PATH}"
  fi

  # Validate combined/ has files (from any source: hooks or src/kubernetes)
  local yaml_count=0
  local other_count=0
  local total_files=0

  while IFS= read -r file; do
    total_files=$((total_files + 1))
    case "${file}" in
      *.yaml) yaml_count=$((yaml_count + 1)) ;;
      *) other_count=$((other_count + 1)) ;;
    esac
  done < <(find "${MANIFESTS_COMBINED_SUB_PATH}" -type f)

  if [[ "${total_files}" -eq 0 ]]; then
    log_error "No manifests to package (${MANIFESTS_COMBINED_SUB_PATH} is empty)"
    exit 1
  fi

  log ""
  log "Found ${yaml_count} manifest file(s) (.yaml)"
  if [[ ${other_count} -gt 0 ]]; then
    log "Found ${other_count} non-manifest file(s)"
  fi

  # Compute the zip filename (used as a built-in token)
  local zip_name="${PROJECT_NAME}-${VERSION}-manifests.zip"

  # Prepare substitution tokens (built-ins + user config)
  log ""
  TOKENS_OUTPUT_SUB_PATH="${MANIFESTS_CONFIG_SUB_PATH}" \
  CONFIG_SUB_PATH="${CONFIG_SUB_PATH}" \
  TOKEN_NAME_STYLE="${TOKEN_NAME_STYLE}" \
  TOKEN_NAME_VALIDATION="${TOKEN_NAME_VALIDATION}" \
  ALLOW_BUILTIN_TOKEN_OVERRIDE="${ALLOW_BUILTIN_TOKEN_OVERRIDE}" \
  CONFIG_VALUE_TRAILING_NEWLINE="${CONFIG_VALUE_TRAILING_NEWLINE}" \
  PROJECT_NAME="${PROJECT_NAME}" \
  VERSION="${VERSION}" \
  DOCKER_TAG="${DOCKER_TAG}" \
  DOCKER_IMAGE_NAME="${DOCKER_IMAGE_NAME}" \
  DOCKER_IMAGE_FULL_URI="${DOCKER_IMAGE_FULL_URI}" \
  TARGET_REGISTRY="${TARGET_REGISTRY}" \
  TARGET_NAMESPACE="${TARGET_NAMESPACE}" \
  IS_RELEASE="${IS_RELEASE}" \
  MANIFESTS_ZIP_FILE_NAME="${zip_name}" \
  "${SCRIPT_DIR}/../util/prepare-substitution-tokens"

  output_var "MANIFESTS_ZIP_FILE_NAME" "${zip_name}"

  log ""
  log "=== Prepare Complete ==="
}

main "$@"
