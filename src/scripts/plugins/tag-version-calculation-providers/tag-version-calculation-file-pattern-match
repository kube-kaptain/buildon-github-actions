#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025-2026 Kaptain contributors (Fred Cooke)
#
# tag-version-calculation-file-pattern-match - Version from file pattern matching
#
# Algorithm:
#   1. Read file and extract version using pattern type or custom regex
#   If TAG_VERSION_USE_SOURCE_VERSION_EXACT=true:
#     Use the extracted version as-is (steps 2-4 skipped)
#   Otherwise:
#     2. Use first N parts as the series prefix (configurable, default 2)
#     3. Find highest existing tag matching that series
#     4. Increment the last component, or start at prefix.1 if no tags exist in series
#
# Inputs (environment variables):
#   TAG_VERSION_PATTERN_TYPE - Pattern type (required):
#     - dockerfile-env-kubectl: defaults to src/docker/Dockerfile, pattern ENV KUBECTL_VERSION=x.y.z
#     - retag-workflow-source-tag: defaults to .github/workflows/build.yaml, pattern docker-source-tag: x.y.z
#     - custom: requires all TAG_VERSION_SOURCE_* inputs
#   TAG_VERSION_SOURCE_SUB_PATH - Override path to directory (required for custom)
#   TAG_VERSION_SOURCE_FILE_NAME - Override file name (required for custom)
#   TAG_VERSION_SOURCE_CUSTOM_PATTERN - Regex with capture group (required for custom)
#   TAG_VERSION_PREFIX_PARTS - Number of parts from source version to use as prefix (default 2, ignored if exact)
#   TAG_VERSION_USE_SOURCE_VERSION_EXACT - Use extracted version as-is without incrementing (default false)
#   TAG_VERSION_MAX_PARTS - Fail if version exceeds this depth (required)
#
# Outputs (stdout):
#   VERSION=x.y.z
#
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${0}")" && pwd)"

# shellcheck disable=SC1091 # path not resolvable at static analysis time
# shellcheck source=../../lib/tag-version-calculation.bash
source "${SCRIPT_DIR}/../../lib/tag-version-calculation.bash"
# shellcheck source=src/scripts/defaults/platform.bash
source "${SCRIPT_DIR}/../../defaults/platform.bash"
# shellcheck source=src/scripts/lib/log.bash
source "${SCRIPT_DIR}/../../lib/log.bash"

# Required inputs
if [[ -z "${TAG_VERSION_PATTERN_TYPE:-}" ]]; then
  log_error "TAG_VERSION_PATTERN_TYPE is required (dockerfile-env-kubectl, retag-workflow-source-tag, custom)"
  exit 1
fi

if [[ -z "${TAG_VERSION_MAX_PARTS:-}" ]]; then
  log_error "TAG_VERSION_MAX_PARTS is required"
  exit 1
fi

# Optional config with default
TAG_VERSION_PREFIX_PARTS="${TAG_VERSION_PREFIX_PARTS:-2}"

# Validate PREFIX_PARTS + 1 doesn't exceed TAG_VERSION_MAX_PARTS (not relevant in exact mode)
if [[ "${TAG_VERSION_USE_SOURCE_VERSION_EXACT:-false}" != "true" ]] && [[ $((TAG_VERSION_PREFIX_PARTS + 1)) -gt ${TAG_VERSION_MAX_PARTS} ]]; then
  log_error "TAG_VERSION_PREFIX_PARTS (${TAG_VERSION_PREFIX_PARTS}) + 1 exceeds TAG_VERSION_MAX_PARTS (${TAG_VERSION_MAX_PARTS})"
  exit 1
fi

# shellcheck disable=SC2154 # SOURCE_SUB_PATH/SOURCE_FILE_NAME/VERSION_PATTERN set by sourced tag-version-calculation.bash
main() {
  # Step 0: Set defaults based on pattern type
  set_defaults_for_type
  log "Pattern type: ${TAG_VERSION_PATTERN_TYPE}"
  log "Source file: ${SOURCE_SUB_PATH}/${SOURCE_FILE_NAME}"

  # Step 1: Extract version from file
  local source_version
  source_version=$(extract_version_from_file "${SOURCE_SUB_PATH}/${SOURCE_FILE_NAME}" "${VERSION_PATTERN}" "source file")
  log "Found version: ${source_version}"

  local version

  if [[ "${TAG_VERSION_USE_SOURCE_VERSION_EXACT:-false}" == "true" ]]; then
    # Exact mode: use the source version as-is, no prefix extraction or incrementing
    log "Exact mode: using source version directly"
    version="${source_version}"
    if git tag --list | grep -qx "${version}"; then
      log_error "Tag '${version}' already exists. In exact mode that means you need to change your source files."
      log_error "Change the regex matched version in ${SOURCE_SUB_PATH}/${SOURCE_FILE_NAME} to get a new build working."
      exit 1
    fi
  else
    # Step 1.5: Validate source version has enough parts for PREFIX_PARTS
    local source_part_count
    source_part_count=$(count_version_parts "${source_version}")
    if [[ ${TAG_VERSION_PREFIX_PARTS} -gt ${source_part_count} ]]; then
      log_error "TAG_VERSION_PREFIX_PARTS (${TAG_VERSION_PREFIX_PARTS}) exceeds source version parts (${source_part_count} in '${source_version}')"
      exit 1
    fi

    # Step 2: Get N-part prefix from source version
    local prefix
    prefix=$(get_prefix "${source_version}" "${TAG_VERSION_PREFIX_PARTS}")
    log "Using version series: ${prefix}.x"

    # Step 3: Find highest existing tag in series
    local highest_tag
    highest_tag=$(find_highest_in_series "${prefix}")
    if [[ -n "${highest_tag}" ]]; then
      log "Highest existing tag in series: ${highest_tag}"
    else
      log "No existing tags in ${prefix}.x series"
    fi

    # Step 4: Increment version
    version=$(increment_version "${prefix}" "${highest_tag}")
  fi

  # Step 5: Validate against TAG_VERSION_MAX_PARTS
  local part_count
  part_count=$(count_version_parts "${version}")
  if [[ ${part_count} -gt ${TAG_VERSION_MAX_PARTS} ]]; then
    log_error "Version '${version}' has ${part_count} parts, exceeds TAG_VERSION_MAX_PARTS=${TAG_VERSION_MAX_PARTS}"
    exit 1
  fi

  # Output the version
  echo "VERSION=${version}"
}

main "$@"
