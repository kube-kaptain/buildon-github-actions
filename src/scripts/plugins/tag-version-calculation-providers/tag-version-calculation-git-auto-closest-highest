#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025-2026 Kaptain contributors (Fred Cooke)
#
# tag-version-calculation-git-auto-closest-highest - Git-based automatic versioning
#
# Algorithm:
#   1. Find closest annotated tag to HEAD (by commit distance)
#   2. If multiple at same distance, use newest by creation date
#   3. Look up highest version in that series across entire repo
#   4. Increment the last component
#
# Inputs (environment variables):
#   TAG_VERSION_MAX_PARTS - Fail if version exceeds this depth (required)
#
# Outputs (stdout):
#   VERSION=x.y.z
#
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${0}")" && pwd)"

# Logging configuration (CI-agnostic)
LOG_ERROR_PREFIX="${LOG_ERROR_PREFIX:-}"
LOG_ERROR_SUFFIX="${LOG_ERROR_SUFFIX:-}"

# Required inputs
if [[ -z "${TAG_VERSION_MAX_PARTS:-}" ]]; then
  echo "${LOG_ERROR_PREFIX}TAG_VERSION_MAX_PARTS is required${LOG_ERROR_SUFFIX}" >&2
  exit 1
fi

# Check if a tag is annotated (heavy) vs lightweight
is_annotated_tag() {
  local tag="${1}"
  local obj_type
  obj_type=$(git cat-file -t "refs/tags/${tag}" 2>/dev/null)
  [[ "${obj_type}" == "tag" ]]
}

# Check if a tag is a pure numeric version (no -rc1, -beta, v-prefix, etc)
is_numeric_version() {
  local version="${1}"
  # Must be only digits and dots
  [[ "${version}" =~ ^[0-9]+(\.[0-9]+)*$ ]]
}

# Find the most recent tag in history (determines our series)
# Primary sort: distance from HEAD (closest wins)
# Tiebreaker: creation date (newest wins)
# Only considers annotated (heavy) tags with numeric versions
find_recent_tag() {
  local tag distance creatordate
  local best_tag="" best_distance=999999 best_date=0

  # Get all annotated tags reachable from HEAD
  for tag in $(git tag --merged HEAD 2>/dev/null); do
    if is_annotated_tag "${tag}" && is_numeric_version "${tag}"; then
      # Calculate distance from HEAD
      distance=$(git rev-list --count "${tag}"..HEAD)
      # Get creation date as Unix timestamp
      creatordate=$(git for-each-ref --format='%(creatordate:unix)' "refs/tags/${tag}")

      # Pick this tag if:
      # - It's closer (smaller distance), OR
      # - Same distance but newer creation date
      if [[ ${distance} -lt ${best_distance} ]] || \
         [[ ${distance} -eq ${best_distance} && ${creatordate} -gt ${best_date} ]]; then
        best_tag="${tag}"
        best_distance=${distance}
        best_date=${creatordate}
      fi
    fi
  done

  if [[ -n "${best_tag}" ]]; then
    echo "${best_tag}"
  fi
}

# Get N-part prefix from version
get_prefix() {
  local version="${1}"
  local num_parts="${2}"

  IFS='.' read -ra parts <<< "${version}"
  local result=""
  for ((i=0; i<num_parts && i<${#parts[@]}; i++)); do
    if [[ ${i} -gt 0 ]]; then
      result+="."
    fi
    result+="${parts[${i}]}"
  done
  echo "${result}"
}

# Find highest tag matching prefix
find_highest_in_series() {
  local prefix="${1}"

  # Get ALL tags in repo matching our prefix with pure numeric versions only
  # The regex ensures: starts with prefix, followed by dot and digits only, no suffixes
  local highest
  highest=$(git tag --list | while read -r tag; do
    if [[ "${tag}" =~ ^${prefix}\.[0-9]+$ ]]; then
      echo "${tag}"
    fi
  done | "${SCRIPT_DIR}/../../util/version-sort" | tail -n1)

  echo "${highest}"
}

# Count parts in a version string
count_version_parts() {
  local version="${1}"
  local dot_count
  dot_count=$(echo "${version}" | tr -cd '.' | wc -c | tr -d ' ')
  echo $((dot_count + 1))
}

# Increment last version component
increment_version() {
  local prefix="${1}"
  local previous_version="${2}"

  if [[ -z "${previous_version}" ]]; then
    echo "${prefix}.1"
    return
  fi

  IFS='.' read -ra parts <<< "${previous_version}"
  local last_idx=$((${#parts[@]} - 1))
  parts[last_idx]=$((parts[last_idx] + 1))
  local IFS='.'
  echo "${parts[*]}"
}

main() {
  # Step 1: Find most recent tag to determine our series
  local recent_tag
  recent_tag=$(find_recent_tag)

  # Step 2: Find highest tag in that series across entire repo
  local version
  if [[ -z "${recent_tag}" ]]; then
    # No tags at all, start at 1.0.0
    version="1.0.0"
  else
    local part_count
    part_count=$(count_version_parts "${recent_tag}")
    local prefix
    prefix=$(get_prefix "${recent_tag}" $((part_count - 1)))
    local highest_tag
    if [[ -n "${prefix}" ]]; then
      highest_tag=$(find_highest_in_series "${prefix}")
    else
      highest_tag="${recent_tag}"
    fi

    # Step 3: Increment the highest
    version=$(increment_version "${prefix}" "${highest_tag}")
  fi

  # Step 4: Validate against TAG_VERSION_MAX_PARTS
  local part_count
  part_count=$(count_version_parts "${version}")
  if [[ ${part_count} -gt ${TAG_VERSION_MAX_PARTS} ]]; then
    echo "${LOG_ERROR_PREFIX}Version '${version}' has ${part_count} parts, exceeds TAG_VERSION_MAX_PARTS=${TAG_VERSION_MAX_PARTS}${LOG_ERROR_SUFFIX}" >&2
    exit 1
  fi

  # Output the version
  echo "VERSION=${version}"
}

main "$@"
