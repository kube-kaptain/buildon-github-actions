#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025-2026 Kaptain contributors (Fred Cooke)
#
# tag-version-calculation-git-auto-closest-highest - Git-based automatic versioning
#
# Algorithm:
#   1. Find closest annotated tag to HEAD (by commit distance)
#   2. If multiple at same distance, use newest by creation date
#   3. Look up highest version in that series across entire repo
#   4. Increment the last component
#
# Inputs (environment variables):
#   TAG_VERSION_MAX_PARTS - Fail if version exceeds this depth (required)
#
# Outputs (stdout):
#   VERSION=x.y.z
#
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${0}")" && pwd)"

# shellcheck disable=SC1091 # path not resolvable at static analysis time
# shellcheck source=../../lib/tag-version-calculation.bash
source "${SCRIPT_DIR}/../../lib/tag-version-calculation.bash"
# shellcheck source=src/scripts/defaults/output-sub-path.bash
source "${SCRIPT_DIR}/../../defaults/output-sub-path.bash"
# shellcheck source=src/scripts/defaults/platform.bash
source "${SCRIPT_DIR}/../../defaults/platform.bash"
# shellcheck source=src/scripts/lib/log.bash
source "${SCRIPT_DIR}/../../lib/log.bash"

# Required inputs
if [[ -z "${TAG_VERSION_MAX_PARTS:-}" ]]; then
  log_error "TAG_VERSION_MAX_PARTS is required"
  exit 1
fi

# Check if a tag is annotated (heavy) vs lightweight
is_annotated_tag() {
  local tag="${1}"
  local obj_type
  obj_type=$(git cat-file -t "refs/tags/${tag}" 2>/dev/null)
  [[ "${obj_type}" == "tag" ]]
}

# Check if a tag is a pure numeric version (no -rc1, -beta, v-prefix, etc)
is_numeric_version() {
  local version="${1}"
  # Must be only digits and dots
  [[ "${version}" =~ ^[0-9]+(\.[0-9]+)*$ ]]
}

# Find the most recent tag in history (determines our series)
# Primary sort: distance from HEAD (closest wins)
# Tiebreaker: creation date (newest wins)
# Only considers annotated (heavy) tags with numeric versions
find_recent_tag() {
  local tag distance creatordate
  local best_tag="" best_distance=999999 best_date=0

  # Get all annotated tags reachable from HEAD
  for tag in $(git tag --merged HEAD 2>/dev/null); do
    if is_annotated_tag "${tag}" && is_numeric_version "${tag}"; then
      # Calculate distance from HEAD
      distance=$(git rev-list --count "${tag}"..HEAD)
      # Get creation date as Unix timestamp
      creatordate=$(git for-each-ref --format='%(creatordate:unix)' "refs/tags/${tag}")

      # Pick this tag if:
      # - It's closer (smaller distance), OR
      # - Same distance but newer creation date
      if [[ ${distance} -lt ${best_distance} ]] || \
         [[ ${distance} -eq ${best_distance} && ${creatordate} -gt ${best_date} ]]; then
        best_tag="${tag}"
        best_distance=${distance}
        best_date=${creatordate}
      fi
    fi
  done

  if [[ -n "${best_tag}" ]]; then
    echo "${best_tag}"
  fi
}

# shellcheck disable=SC2154 # OUTPUT_SUB_PATH set by sourced defaults
main() {
  # Step 1: Find most recent tag to determine our series
  local recent_tag
  recent_tag=$(find_recent_tag)

  # Step 2: Find highest tag in that series across entire repo
  local version
  if [[ -z "${recent_tag}" ]]; then
    # No tags at all, start at 1.0.0
    version="1.0.0"
  else
    local part_count
    part_count=$(count_version_parts "${recent_tag}")
    local prefix
    prefix=$(get_prefix "${recent_tag}" $((part_count - 1)))
    local highest_tag
    if [[ -n "${prefix}" ]]; then
      highest_tag=$(find_highest_in_series "${prefix}")
    else
      highest_tag="${recent_tag}"
    fi

    # Step 3: Increment the highest
    version=$(increment_version "${prefix}" "${highest_tag}")
  fi

  # Step 4: Validate against TAG_VERSION_MAX_PARTS
  local part_count
  part_count=$(count_version_parts "${version}")
  if [[ ${part_count} -gt ${TAG_VERSION_MAX_PARTS} ]]; then
    log_error "Version '${version}' has ${part_count} parts, exceeds TAG_VERSION_MAX_PARTS=${TAG_VERSION_MAX_PARTS}"
    exit 1
  fi

  # Write the version to file
  echo "${version}" > "${OUTPUT_SUB_PATH}/versions-and-naming/tag-version-calculation-provider/VERSION"
}

main "$@"
