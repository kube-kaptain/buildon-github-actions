#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025 Kaptain contributors (Fred Cooke)
#
# substitute-shell-style-var - Substitutes a single shell-style ${VAR} variable in files
#
# This script is DUMB - it does literal find-replace of ${VAR_NAME} with value.
# No case conversion, no intelligence. Caller is responsible for translating
# variable names to the desired case style before calling this script.
#
# Inputs (environment variables):
#   VAR_NAME     - Variable name to find (exact match for ${VAR_NAME})
#   VAR_VALUE    - Value to substitute
#   INPUT_PATH   - File or directory to process (required)
#   OUTPUT_PATH  - Where to write results (required, must differ from INPUT_PATH)
#
# Outputs (stdout):
#   Substitution count (number of replacements made)
#
# Example:
#   VAR_NAME="project-name"
#   VAR_VALUE="my-app"
#   INPUT_PATH="src/kubernetes/deployment.yaml"
#   OUTPUT_PATH="target/substituted/deployment.yaml"
#
set -euo pipefail

# Logging configuration (CI-agnostic)
LOG_ERROR_PREFIX="${LOG_ERROR_PREFIX:-}"
LOG_ERROR_SUFFIX="${LOG_ERROR_SUFFIX:-}"

# Required inputs
VAR_NAME="${VAR_NAME:?VAR_NAME is required}"
VAR_VALUE="${VAR_VALUE:?VAR_VALUE is required}"
INPUT_PATH="${INPUT_PATH:?INPUT_PATH is required}"
OUTPUT_PATH="${OUTPUT_PATH:?OUTPUT_PATH is required}"

# Validate paths differ
if [[ "$INPUT_PATH" == "$OUTPUT_PATH" ]]; then
  echo "${LOG_ERROR_PREFIX}INPUT_PATH and OUTPUT_PATH must differ${LOG_ERROR_SUFFIX}" >&2
  exit 1
fi

# Escape special characters for sed substitution
escape_for_sed() {
  printf '%s\n' "$1" | sed -e 's/[\\/&]/\\&/g'
}

# Substitute variable in a single file
substitute_file() {
  local input_file="$1"
  local output_file="$2"
  local value_escaped="$3"

  # Copy input to output first
  cp "$input_file" "$output_file"

  local before_content
  before_content=$(cat "$output_file")

  # Substitute ${VAR_NAME} with value
  sed -i.bak -e "s/\${${VAR_NAME}}/${value_escaped}/g" "$output_file"
  rm -f "${output_file}.bak"

  # Count substitutions
  local after_content
  after_content=$(cat "$output_file")

  if [[ "$before_content" != "$after_content" ]]; then
    # Count how many ${VAR_NAME} patterns were replaced
    local before_count after_count
    before_count=$(echo "$before_content" | grep -o "\${${VAR_NAME}}" | wc -l | tr -d ' ') || before_count=0
    after_count=$(echo "$after_content" | grep -o "\${${VAR_NAME}}" | wc -l | tr -d ' ') || after_count=0
    local diff=$((before_count - after_count))
    if [[ $diff -gt 0 ]]; then
      echo "$diff"
      return
    fi
  fi

  echo "0"
}

main() {
  # Validate input exists
  if [[ ! -e "$INPUT_PATH" ]]; then
    echo "${LOG_ERROR_PREFIX}Input path not found: $INPUT_PATH${LOG_ERROR_SUFFIX}" >&2
    exit 1
  fi

  local value_escaped
  value_escaped=$(escape_for_sed "$VAR_VALUE")

  local total_subs=0

  # Handle file vs directory
  if [[ -f "$INPUT_PATH" ]]; then
    # Single file
    mkdir -p "$(dirname "$OUTPUT_PATH")"
    local count
    count=$(substitute_file "$INPUT_PATH" "$OUTPUT_PATH" "$value_escaped")
    total_subs=$((total_subs + count))
  elif [[ -d "$INPUT_PATH" ]]; then
    # Directory - process all files recursively
    mkdir -p "$OUTPUT_PATH"

    while IFS= read -r input_file; do
      local rel_path="${input_file#$INPUT_PATH/}"
      local output_file="$OUTPUT_PATH/$rel_path"

      mkdir -p "$(dirname "$output_file")"
      local count
      count=$(substitute_file "$input_file" "$output_file" "$value_escaped")
      total_subs=$((total_subs + count))
    done < <(find "$INPUT_PATH" -type f)
  else
    echo "${LOG_ERROR_PREFIX}Input path is neither file nor directory: $INPUT_PATH${LOG_ERROR_SUFFIX}" >&2
    exit 1
  fi

  echo "$total_subs"
}

main "$@"
