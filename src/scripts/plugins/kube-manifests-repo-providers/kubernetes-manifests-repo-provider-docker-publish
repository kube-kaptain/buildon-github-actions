#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025 Kaptain contributors (Fred Cooke)
#
# kubernetes-manifests-repo-provider-docker-publish - Publishes manifests zip as a Docker image
#
# Uses registry.k8s.io/pause:3.10.1 as base, stores zip at /<original-filename>
#
# Inputs (environment variables):
#   MANIFESTS_ZIP_PATH  - Path to zip file (required)
#   OUTPUT_PATH         - Build output directory (default: target)
#   TARGET_REGISTRY     - Container registry (default: ghcr.io)
#   TARGET_BASE_PATH    - Path between registry and image name (optional)
#   TARGET_IMAGE_NAME   - Image name (required)
#   DOCKER_TAG          - Tag for the image (required, e.g., 1.2.3-manifests)
#   IS_RELEASE          - "true" to push (default: false)
#   CONFIRM_IMAGE_DOESNT_EXIST - "true" to fail if exists (default: true)
#
# Outputs (GITHUB_OUTPUT):
#   MANIFESTS_URI       - Full image reference
#   MANIFESTS_PUBLISHED - Whether manifests were published
#
set -euo pipefail

# Logging configuration (CI-agnostic)
LOG_ERROR_PREFIX="${LOG_ERROR_PREFIX:-}"
LOG_ERROR_SUFFIX="${LOG_ERROR_SUFFIX:-}"

# Base image for manifest containers
BASE_IMAGE="registry.k8s.io/pause:3.10.1"

# Required inputs
MANIFESTS_ZIP_PATH="${MANIFESTS_ZIP_PATH:?MANIFESTS_ZIP_PATH is required}"
TARGET_IMAGE_NAME="${TARGET_IMAGE_NAME:?TARGET_IMAGE_NAME is required}"
DOCKER_TAG="${DOCKER_TAG:?DOCKER_TAG is required}"

# Optional inputs with defaults
OUTPUT_PATH="${OUTPUT_PATH:-target}"
TARGET_REGISTRY="${TARGET_REGISTRY:-ghcr.io}"
TARGET_BASE_PATH="${TARGET_BASE_PATH:-}"
IS_RELEASE="${IS_RELEASE:-false}"
CONFIRM_IMAGE_DOESNT_EXIST="${CONFIRM_IMAGE_DOESNT_EXIST:-true}"

# Build output structure
PUBLISH_PATH="$OUTPUT_PATH/publish/docker"

# Assemble full image URI
if [[ -n "$TARGET_BASE_PATH" ]]; then
  TARGET_IMAGE_FULL_URI="${TARGET_REGISTRY}/${TARGET_BASE_PATH}/${TARGET_IMAGE_NAME}:${DOCKER_TAG}"
else
  TARGET_IMAGE_FULL_URI="${TARGET_REGISTRY}/${TARGET_IMAGE_NAME}:${DOCKER_TAG}"
fi

confirm_image_doesnt_exist() {
  local image="$1"

  if docker manifest inspect "$image" &>/dev/null; then
    echo "${LOG_ERROR_PREFIX}Target image already exists in registry: $image${LOG_ERROR_SUFFIX}" >&2
    return 1
  fi

  echo "Confirmed image does not exist in registry (safe to push)" >&2
  return 0
}

output_var() {
  local name="$1"
  local value="$2"

  echo "${name}=${value}"

  if [[ -n "${GITHUB_OUTPUT:-}" ]]; then
    echo "${name}=${value}" >> "$GITHUB_OUTPUT"
  fi
}

main() {
  echo "=== Kubernetes Manifests Publish: Docker ===" >&2
  echo "Manifests zip: $MANIFESTS_ZIP_PATH" >&2
  echo "Base image: $BASE_IMAGE" >&2
  echo "Target: $TARGET_IMAGE_FULL_URI" >&2
  echo "Is Release: $IS_RELEASE" >&2
  echo "==============================================" >&2

  # Validate zip exists
  if [[ ! -f "$MANIFESTS_ZIP_PATH" ]]; then
    echo "${LOG_ERROR_PREFIX}Manifests zip not found: $MANIFESTS_ZIP_PATH${LOG_ERROR_SUFFIX}" >&2
    exit 1
  fi

  # Confirm target doesn't exist (if configured)
  if [[ "$CONFIRM_IMAGE_DOESNT_EXIST" == "true" ]]; then
    confirm_image_doesnt_exist "$TARGET_IMAGE_FULL_URI" || exit 1
  fi

  # Create publish build directory (instead of temp dir)
  rm -rf "$PUBLISH_PATH"
  mkdir -p "$PUBLISH_PATH"

  # Copy zip to publish dir (preserve original name)
  local zip_filename
  zip_filename=$(basename "$MANIFESTS_ZIP_PATH")
  cp "$MANIFESTS_ZIP_PATH" "$PUBLISH_PATH/"

  # Create Dockerfile
  cat > "$PUBLISH_PATH/Dockerfile" <<EOF
FROM ${BASE_IMAGE}
COPY ${zip_filename} /${zip_filename}
EOF

  echo "Building manifest image..." >&2
  docker build -t "$TARGET_IMAGE_FULL_URI" "$PUBLISH_PATH"

  # Push if release
  if [[ "$IS_RELEASE" == "true" ]]; then
    echo "Pushing: $TARGET_IMAGE_FULL_URI" >&2
    docker push "$TARGET_IMAGE_FULL_URI"
    output_var "MANIFESTS_PUBLISHED" "true"
  else
    echo "Skipping push (IS_RELEASE=$IS_RELEASE)" >&2
    output_var "MANIFESTS_PUBLISHED" "false"
  fi

  output_var "MANIFESTS_URI" "$TARGET_IMAGE_FULL_URI"

  echo "Kubernetes Manifests Publish: Docker complete" >&2
}

main "$@"
