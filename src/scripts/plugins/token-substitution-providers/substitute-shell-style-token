#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2025-2026 Kaptain contributors (Fred Cooke)
#
# substitute-shell-style-token - Substitutes a single shell-style ${TOKEN} in files
#
# Called from tokens directory as working directory.
# Substitutes ${TOKEN_NAME} with TOKEN_VALUE in-place in target file or all files in target dir.
#
# Usage:
#   substitute-shell-style-token <token-file> <target-file-or-dir>
#
# Arguments:
#   token-file         - Path to token file (relative to current dir, becomes token name)
#   target-file-or-dir - File or directory to substitute into (absolute path)
#
# Environment:
#   CONFIG_VALUE_TRAILING_NEWLINE - How to handle trailing newlines in token values
#                                   (passed to prepare-token-name-and-value.bash)
#
# Example:
#   cd tokens-dir
#   substitute-shell-style-token project-name /abs/path/to/target
#   substitute-shell-style-token category/sub-var /abs/path/to/target
#
set -euo pipefail

# Locate script directory for sourcing helper
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Logging configuration (CI-agnostic)
LOG_ERROR_PREFIX="${LOG_ERROR_PREFIX:-}"
LOG_ERROR_SUFFIX="${LOG_ERROR_SUFFIX:-}"

# Validate arguments
if [[ ${#} -ne 2 ]]; then
  echo "${LOG_ERROR_PREFIX}Usage: substitute-shell-style-token <token-file> <target-file-or-dir>${LOG_ERROR_SUFFIX}" >&2
  exit 1
fi

TOKEN_FILE="${1}"
TARGET="${2}"

# Validate token file exists
if [[ ! -f "${TOKEN_FILE}" ]]; then
  echo "${LOG_ERROR_PREFIX}Token file not found: ${TOKEN_FILE}${LOG_ERROR_SUFFIX}" >&2
  exit 1
fi

# Validate target exists (file or directory)
if [[ -d "${TARGET}" ]]; then
  TARGET_MODE="dir"
elif [[ -f "${TARGET}" ]]; then
  TARGET_MODE="file"
else
  echo "${LOG_ERROR_PREFIX}Target not found: ${TARGET}${LOG_ERROR_SUFFIX}" >&2
  exit 1
fi

# Source shared helper to get TOKEN_NAME and TOKEN_VALUE
# shellcheck source=src/scripts/lib/prepare-token-name-and-value.bash
# shellcheck disable=SC1091 # shellcheck can't resolve dynamic path
source "${SCRIPT_DIR}/../../lib/prepare-token-name-and-value.bash"

# Substitute ${TOKEN_NAME} with TOKEN_VALUE in all files in target directory
# Uses single-pass left-to-right string manipulation (no sed - fragile with special chars)
substitute_in_file() {
  local file="${1}"
  local token_name="${2}"
  local value="${3}"

  # Read file content preserving trailing newlines exactly
  local content
  content=$(cat "${file}" && echo x)
  content="${content%x}"

  # Pattern to match: ${TOKEN_NAME}
  local pattern="\${${token_name}}"

  # Check if pattern exists in content (optimization: skip files without matches)
  if [[ "${content}" != *"${pattern}"* ]]; then
    return 0
  fi

  # Single-pass left-to-right: split on pattern, reassemble with value
  # This prevents infinite loops with self-referential tokens
  local result=""
  local remainder="${content}"

  while [[ "${remainder}" == *"${pattern}"* ]]; do
    # Extract prefix before first occurrence
    # Pattern: ${remainder%%\$\{${token_name}\}*}
    # Level 1 (double quotes): \$ -> $, \{ -> \{ (backslash not special before brace)
    # Level 2 (glob pattern): \{ -> { (backslash escapes brace)
    # Result: matches ${token_name}<anything>
    # shellcheck disable=SC2295 # token_name is validated by token-name-validators (no glob chars)
    local prefix="${remainder%%\$\{${token_name}\}*}"
    # shellcheck disable=SC2295 # token_name is validated by token-name-validators (no glob chars)
    local suffix="${remainder#*\$\{${token_name}\}}"
    result="${result}${prefix}${value}"
    remainder="${suffix}"
  done
  result="${result}${remainder}"

  # Write result back to file (preserving exact content)
  printf '%s' "${result}" > "${file}"
}

# Process target file(s)
# shellcheck disable=SC2153,SC2154 # TOKEN_NAME/TOKEN_VALUE set by sourced prepare-token-name-and-value.bash
if [[ "${TARGET_MODE}" == "file" ]]; then
  substitute_in_file "${TARGET}" "${TOKEN_NAME}" "${TOKEN_VALUE}"
else
  while IFS= read -r -d '' file; do
    substitute_in_file "${file}" "${TOKEN_NAME}" "${TOKEN_VALUE}"
  done < <(find "${TARGET}" -type f -print0)
fi
